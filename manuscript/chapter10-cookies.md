# Cookies и сессии
В этой главе мы коснемся основ работы с *сессиями* и хранения *cookies*. Оба понятия тесно связаны друг с другом и позволяют сохранять текущее состояние приложения. В предыдущей главе фреймворк Django использовал сессии и cookies для реализации функций входа и выхода в/из системы. Но это делалось без нашего явного указания использовать их. Здесь мы рассмотрим, что именно происходит изнутри, и как мы можем сами использовать cookies для других целей.

## Cookies, Cookies используются везде!
Всякий раз при создании запроса к сайту, вебсервер возвращает содержимое запрашиваемой страницы. Кроме него также может посылаться один или несколько cookies как часть запроса. Считайте, что cookie - это небольшой фрагмент информации, отправляемой с сервера клиенту. Перед отправкой запроса, клиент проверяет существуют ли у него cookies соответствующие адресу сервера. Если да, то они посылаются вместе с запросом. Затем сервер может обработать cookies как часть контекста запроса и сгенерировать подходящий ответ.

Например, Вы можете войти на сайт с определенным именем пользователя и паролем. После аутентификации сервер может вернуть вашему браузеру cookie, который содержит Ваше имя пользователя, указывая на то, что Вы зашли на сайт. При каждом запросе эта информация посылается обратно на сервер, где она используется для выдачи соответствующей страницы - при этом в определенных местах страницы может быть вставлено Ваше имя пользователя. Ваш сеанс работы с браузером не может длиться вечно, поэтому cookies *истекут* через определенный промежуток времени - они не могут быть бесконечной длины. Для веб приложения содержащего содержащего конфиденциальную информацию cookies могут истечь через несколько минут при бездействии со стороны пользователя. Для других веб приложений с не такой важной информацией могут истечь через полчаса после последнего взаимодействия или даже через недели.

I> ### История появления Cookie
I> Термин *cookie* на самом деле возник не от слова печенье (так переводится cookie - *прим. переводчика*), а от термина *magic cookie*, пакета данных, которые программа получает и затем отправляет обратно неизменными. В 1994 году *MCI* попросило *Netscape Communications* реализовать способ с помощью которого можно было бы хранить информацию между HTTP запросами.  Это нужно было, чтобы надежно хранить содержимое виртуальной корзины покупок пользователя для приложения электронной коммерции, которое они разрабатывали. Программист Netscape Лу Монтулли (Lou Montulli) использовал понятие magic cookie и применил его для веб коммуникаций.
I> 
I> Вы можете узнать больше о [cookies и их истории на Википедии](http://en.wikipedia.org/wiki/HTTP_cookie#History). Конечно после такой великолепной идеи, Монтулли подал заявку на патент, который можно прочитать [US патент 5774670](http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&Sect2=HITOFF&d=PALL&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.htm&r=1&f=G&l=50&s1=5774670.PN.&OS=PN/5774670&RS=PN/5774670).

Передача информации в виде cookies может привести к потенциальным проблемам безопасности при проектировании Вашего приложения. Из-за этого разработчики веб приложений должны быть очень осторожны при использовании cookies. Каждый раз при использовании cookies разработчик должен спрашивать себя: ***действительно** ли необходимо информацию, которую Вы хотите хранить в cookie, посылать и хранить на машине клиента?* Во многих случаях, существуют альтернативные и более безопасные решения проблемы. Например, не стоит передавать номер кредитной карточки пользователя сайту электронной коммерции в виде cookie. Что если компьютер пользователя взломают? Cookie может быть перехвачен вредноносной программой. После этого хакер сможет получить номер кредитной карточки пользователя - все из-за в корне ошибочного дизайна Вашего веб приложения. В этой главе рассматриваются фундаментальные основы cookie на стороне клиента и хранения сессий на стороне сервера для веб-приложений.

{id="fig-ch10-bbcnews"}
![Снимок экрана веб сайта BBC News (с хостингом в Великобритании) с предупреждающим сообщением об использовании cookie в верхней части страницы.](images/ch10-bbcnews.png)

I> ### Об использовании Cookies в Европейском Союзе
I> В 2011 году Европейский Союз (ЕС) ввел *"закон о cookie"* на всей территории ЕС, согласно которому все сайты с хостингом в ЕС должны выдавать предупреждающее сообщением об использовании cookie, когда пользователь посещает сайт первый раз. На [приведенном выше рисунке](#fig-ch10-bbcnews) показано такое предупреждающее сообщение для сайта BBC News. Прочитать о [законе можно здесь](https://ico.org.uk/for-organisations/guide-to-pecr/cookies-and-similar-technologies/).
I>
I> Если вы разрабатываете сайт, вам нужно знать об этом законе и других законах, особенно касающихся доступности и объяснимости, ставшей актуальной в последнее время.

## Сессии и протокол без сохранения состояния
Все взаимодействия между веб браузерами (клиентами) и серверами осуществляется с помощью [HTTP протокола](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol). Как мы уже говорили ранее, HTTP - это [протокол без сохранения состояния](http://en.wikipedia.org/wiki/Stateless_protocol). Это означает, что компьютер клиента, на котором работает веб браузер должен установить новое сетевое соединение ([TCP соединение](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)) с сервером каждый раз при запросе ресурса (HTTP `GET`) или отправке (HTTP `POST`) [^1].

Без постоянной связи между клиентом и сервером программное обеспечение на обеих сторонах не может использовать саму связь для *хранения состояния сеанса*. Например, клиент должен передавать серверу каждый раз кто вошел в веб приложение на конкретном компьютере. Это так называемый диалог между клиентом и сервером и он является основой для *сессии* - [полупостоянного обмена информацией](http://en.wikipedia.org/wiki/Session_(computer_science)). Являясь протоколом без сохранения состояния, HTTP сильно усложняет хранение состояния сессии - но, к счастью, существует несколько методов, которые можно использовать для решения этой проблемы.

Чаще всего для хранения состояния используется *идентификатор сессии*, хранящийся в виде cookie на компьютере клиента. Идентификатор сессии можно считать токеном (последовательностью символов или *строкой*), который используется для определения отдельной сессии в рамках конкретного веб приложения. Вместо хранения различной информации в виде cookies на стороне клиента (например, имя пользователя, имена или пароли), хранится только идентификатор сессии, который затем сопоставляется структуре данных на веб сервере. В этой структуре данных, Вы можете хранить любую информацию, которая Вам требуется. Этот метод **гораздо более безопасный** способ хранения информации о пользователях. Таким образом, информацию нельзя получить, взломав незащищенный клиент или отслеживая линию связи.


Если вы используете современный правильной настроенный браузер, то он будет поддерживать cookies. Практически каждый веб-сайт, который Вы посещаете, будет создавать новую *сессию*. Вы можете убедиться в этом сами -- посмотрите на [снимок экрана, показанный ниже](#fig-ch10-sessionid). В Google Chrome вы можете просматривать файлы cookie для открытого в данный момент веб-сайта из Инструментов разработчика, выбрав *Настройки Chrome > Дополнительные инструменты > Инструменты разработчика*.  Когда откроется панель «Инструменты разработчика», перейдите на вкладку *Application* и найдите *Cookies* в левой части меню *Storage*. Если у Вас открыта страница Rango, то Вы должны увидеть cookie с именем `sessionid`. Cookie `sessionid` состоит из последовательности букв и цифр, которые Django использует для уникальной идентификации вашего компьютера с текущей сессией. С помощью этого идентификатора сессии можно получить доступ ко всей информации сессии, но она хранятся только на *серверной стороне*.

{id="fig-ch10-sessionid"}
![Снимок экрана Google Chrome с открытой панелью Инструментов разработчика и выделенным `sessionid` cookie.](images/ch10-sessionid.png)

I> ### Если не использовать Cookies
I> Альтернативный способ сохранения информации о состоянии *без cookies* заключается в кодировании идентификатора сессии в URL. Например, возможно Вы видели PHP страницы с URL-адресами вида: `http://www.site.com/index.php?sessid=someseeminglyrandomandlongstring1234`. При этом Вам не нужно хранить cookies на компьютере клиента, но URL-адреса становятся довольно уродливыми. Эти URL идут вразрез с принципами Django, который заключается в предоставлении простых и человекопонятных URL-адресов.

## Настройка сессий в Django
Хотя все должно быть настроено и работать правильно, тем не менее полезно изучить такие функции выполняет каждый модуль Django. В случае сессий, Django предоставляет [ПО промежуточного уровня](https://docs.djangoproject.com/en/2.0/topics/http/middleware/), которое реализует функционал сессий.

Чтобы проверить, что все работает правильно, откройте файл `settings.py` проекта Django. В файле найдите список `MIDDLEWARE`. В нём должен находится модуль `django.contrib.sessions.middleware.SessionMiddleware`. Если его нет, то добавьте его в список. Именно `SessionMiddleware` позволяет создавать уникальные `sessionid` cookies.

`SessionMiddleware` создано таким образом, что позволяет хранить информацию о сессии различным образом. Существует множество методов, которые можно использовать - Вы можете хранить всё в файле, в базе данных или даже в кэше. Самый простой способ - это использовать приложение `django.contrib.sessions` для хранения информации о сессии в модели/базе данных Django
The `SessionMiddleware` (а именно, модели `django.contrib.sessions.models.Session`). Для этого нужно добавить `django.contrib.sessions` в кортеж `INSTALLED_APPS` в файл `settings.py` Вашего Django проекта. Помните, что если Вы добавили его только что, необходимо обновить базу данных с помощью команд миграции.

T> ### Кеширование сессий
T> Если Вы хотите ускорить работу приложения, можно попробовать использовать кэш для хранения информации о сессии. Прочитайте [официальную Django документацию, связанную с кэшированием сессий](https://docs.djangoproject.com/en/2.0/topics/http/sessions/#using-cached-sessions).

## Использование сессий с cookie
Хотя все современные браузеры поддерживают cookies, определенные cookies могут блокироваться в зависимости от настроек безопасности Вашего браузера. Прежде чем продолжить убедитесь, что у Вас включена поддержка cookies. Скорее всего всё уже и так готово к работе и Вы можете продолжать.

### Проверка функционала cookie
Для проверки cookies, Вы можете использовать несколько удобных методов, предоставляемых объектом Django's `request`. Особый интерес для нас представляют три метода - `set_test_cookie()`, `test_cookie_worked()` и `delete_test_cookie()`. В одном предсатвлении Вам нужно будет установить тестовый cookie. В другом - проверить, что cookie существует. Для тестирования cookies нужно два разных представления, поскольку необходимо подождать пока клиент получит cookie от сервера.

Для этого простой проверки мы будем использовать два ранее существующих представления: `index()` и `about()`. Вместо того, чтобы что-то отображать на самих страницах, мы будем использовать терминал, в котором запускается Django сервер для разработки, чтобы проверить правильно ли работают cookies.

В файле `views.py` Rango найдите Ваше представление `index()`. Добавьте следующую строку в представление. Чтобы строка действительно выполнялась, убедитесь, что она находится в первой строке представления.

{lang="python",linenos=off}
	request.session.set_test_cookie()

В представление `about()`  добавьте следующие три строки в самом начале функции.

{lang="python",linenos=off}
	if request.session.test_cookie_worked():
	    print("TEST COOKIE WORKED!")
	    request.session.delete_test_cookie()

Сохранив эти изменения, запустите Django сервер для разработки и перейдите на главную страницу Rango `http://127.0.0.1:8000/rango/`. Теперь перейдите на страницу about и Вы должны увидеть сообщение `TEST COOKIE WORKED!` в консоли Django сервера для разработки, как показано на [рисунке ниже](#fig-ch10-test-cookie).

{id="fig-ch10-test-cookie"}
![Снимок экрана консоли Django сервера для разработки с сообщением `TEST COOKIE WORKED!`.](images/ch10-test-cookie.png)

Если сообщение не выводится, проверьте настройки безопасности Вашего браузера. Настройки могут запрещать браузеру принимать cookie.

## Пример использования cookies на стороне клиента: счетчик количества посещений сайта
Убедившись, что cookies работают, давайте реализуем очень простой счетчик посещений сайта. Для этого мы создадим два cookies: один для подсчета количества посещений пользователем сайта Rango и второй для хранения времени последнего посещения сайта. Хранение даты и времени последнего посещения позволит нам увеличивать счетчик только раз в день (например) и таким образом избежать накрутки счетчика, если одни и те же люди будут заходить на сайт.

Будем считать, что пользователь посещает сайт Rango, когда заходит на главную страницу. Откройте файл `view.py`. давайте сначала создадим функцию -- которой передаются объекты `request` и `response` -- для обработки cookies (`visitor_cookie_handler()`). Затем мы можем использовать её в представлении `index()` Rango. В `views.py` добавьте следующую функцию. Обратите внимание, что на самом деле это не представление, поскольку оно не возвращает объект `response` - это просто [*вспомогательная функция*](https://web.cs.wpi.edu/~cs1101/a05/Docs/creating-helpers.html).

{lang="python",linenos=off}
	def visitor_cookie_handler(request, response):
	    # Получаем количество посещений сайта.
	    # Мы используем функцию COOKIES.get(), чтобы получить cookie с количеством посещений.
	    # Если cookie существует, то возвращаемое значение преобразуется в целое число.
	    # Если cookie не существует, то используется значение по умолчанию 1.
	    visits = int(request.COOKIES.get('visits', '1'))
	
	    last_visit_cookie = request.COOKIES.get('last_visit', str(datetime.now()))
	    last_visit_time = datetime.strptime(last_visit_cookie[:-7],
	                                        '%Y-%m-%d %H:%M:%S')
	
	    # Прошло больше суток с момента последнего посещения...
	    if (datetime.now() - last_visit_time).days > 0:
	        visits = visits + 1
	        # Обновляем last_visit_cookie после того как мы обновили счетчик
	        response.set_cookie('last_visit', str(datetime.now()))
	    else:
	        # Устанавливаем last_visit_cookie
	        response.set_cookie('last_visit', last_visit_cookie)
	    
	    # Обновляем/устанавливаем cookie посещений
	    response.set_cookie('visits', visits)

Эта вспомогательная функция принимает объекты `request` и `response` -- поскольку мы хотим получить доступ к передаваемым серверу cookies с помощью `request` и добавить или обновить cookies в `response`. В функции мы вызываем функцию `request.COOKIES.get()`, которая является дополнительной вспомогательной функцией, предоставляемой Django. Если cookie существует, она возвращает его значение. Если нет -- мы можем выдать значение по умолчанию. Получив значения для каждого cookie, мы можем определить прошел ли день (`.days`) между последним посещением.

Если Вы хотите протестировать этот код не ожидая целый день, измените `days` на `seconds`. Таким образом, счетчик посещений будет обновляться, если пользователь посещал сайт секундой ранее, а не днём.

**Обратите внимание, что все значения cookie возвращаются в виде строк**; *даже, если cookie содержит только цифры, вернется не число, а строка*. Вы должны вручную преобразовать результат в правильный тип, поскольку в cookie не сохраняется информация о типе значения.

Если cookie не существует, Вы можете создать его с помощью метода set_cookie() объекта `response`. Метод принимает два значения: название cookie, которое нужно создать (в виде строки) и значение cookie. В этом случае, не важно какой тип Вы передаёте для значения - он будет автоматически приведен к строке.

Поскольку мы используем `datetime` нам надо импортировать (`import`) его в `views.py` в начале файла.

{lang="python",linenos=off}
	from datetime import datetime

Затем обновите представление `index()`, чтобы вызвать вспомогательную функцию `cookie_handler_function()`. Для этого нам необходимо сначала получить `response`.

{lang="python",linenos=off}
	def index(request):
	    category_list = Category.objects.order_by('-likes')[:5]
	    page_list = Page.objects.order_by('-views')[:5]
	    context_dict = {'categories': category_list, 'pages': page_list}
	    
	    # Получаем наш объект Response заранее, чтобы мы могли добавить информацию о cookie.
	    response = render(request, 'rango/index.html', context_dict)
	
	    # Вызываем вспомогательную функцию для обработки cookies
	    visitor_cookie_handler(request, response)
	
	    # Возвращаем ответ обратно пользователю, обновляя при этом любые изменившиеся cookies.
	    return response

{id="fig-ch10-cookie-visits"}
![Снимок экрана Google Chrome с открытымы инструментами разработчика, где показаны cookies для Rango, используя сервер для разработок Django по адресу `127.0.0.1`. Обратите внимание на cookie `visits` - пользователь в общей сложности посетил сайт три раза, с интервалом по крайней мере в один день.](images/ch10-cookie-visits.png)

Теперь, если Вы посетите главную страницу Rango и откроете инструменты для просмотра cookie Вашего браузера (например, Инструменты разработчика Google Chrome), Вы должны увидеть cookies `visits` и `last_visit`. На [рисунке выше](#fig-ch10-cookie-visits) показаны эти cookies. Вместо использования инструментов разработчика Вы можете обновить `index.html` и добавить `<p>visits: {{ visits }}</p>` в шаблон, чтобы увидеть число посещений. Также Вам нужно будет обновить словарь контекта добавив в него значение `visits` (т. е., `'visits': int(request.COOKIES.get('visits', '1')),`).

## Данные сессии
В предыдущем примере показано как мы можем хранить и изменять cookies на стороне клиента - или данные, хранящиеся у клиента. Но безопаснее хранить информацию о сессии на стороне сервера. Тогда мы можем использовать cookie идентификатора сессии, который хранится на стороне клиента (но не предоставляет какой-либо информации), чтобы получить эти данные.

Чтобы использовать сессии, на основе cookies, необходимо осуществить следующие шаги.

1.  Удостовериться, что список `MIDDLEWARE_CLASSES` в модуле `settings.py` содержит `django.contrib.sessions.middleware.SessionMiddleware`.
2.  Настроить бекенд Вашей сесссии. Убедитесь, что `django.contrib.sessions` находится в `INSTALLED_APPS` файла `settings.py`. Если нет - добавить его и выполнить команду миграции базы данныых -  `python manage.py migrate`.
3.  По умолчанию, бекендом является база данных, но Вы можете выбрать другой (например, кэш). Смотри [Django документацию по сесссиям для других конфигураций бекендов](https://docs.djangoproject.com/en/2.0/topics/http/sessions/).

Теперь вместо хранения непосредственно cookies в запросе (и таким образом на машине клиента), Вы можете получить доступ к cookies на стороне сервера, используя метод `request.session.get()`, и хранить их в `request.session[]`. Обратите внимание, что cookie идентификатора сессии всё равно используется для идентификации машины клиента (поэтому технически cookie на стороне браузера существует). Но все данные пользователя/сессии хранятся на серверной стороне. 
Instead of storing the cookies directly in the request (and thus on the client's machine), you can access server-side data via the method `request.session.get()` and store them with `request.session[]`. Note that a session ID cookie is still used to remember the client's machine (so technically a browser side cookie exists). However, all the user/session data is stored server side. ПО промежуточного уровня Django для работы с сессиями берет на себя задачи по работе с cookie на стороне клиента и хранению данных пользователя/сессии.

Чтобы использовать данные на стороне сервера, нам необходимо провести рефакторинг кода, который мы уже написали. Во-первых, нам нужно обновить функцию visitor_cookie_handler (), чтобы она использовала cookies на стороне сервера. Для этого вызовите `request.session.get()` и сохраните их, поместив в словарь `request.session[]`. Чтобы упростить нам задачу мы создали вспомогательную функцию `get_server_side_cookie()`, которая запрашивает cookie у запроса. Если cookie находится в данных сессии, то возвращается его значение. В противном случае возвращается значение по умолчанию.

Поскольку все cookies хранятся на стороне сервера, мы не будем непосредственно менять ответ сервера. Поэтому мы можем удалить `response` из аргументов функции `visitor_cookie_handler()`.

{lang="python",linenos=off}
	# Вспомогательный метод
	def get_server_side_cookie(request, cookie, default_val=None):
	    val = request.session.get(cookie)
	    if not val:
	        val = default_val
	    return val
	
	# Обновленное определение функции
	def visitor_cookie_handler(request):
	    visits = int(get_server_side_cookie(request, 'visits', '1'))
	    last_visit_cookie = get_server_side_cookie(request,
	                                               'last_visit',
	                                               str(datetime.now()))
	    last_visit_time = datetime.strptime(last_visit_cookie[:-7],
	                                        '%Y-%m-%d %H:%M:%S')
	
	    # Если прошло более одного дня с последнего посещения...
	    if (datetime.now() - last_visit_time).days > 0:
	        visits = visits + 1
	        # теперь обновляем cookie last visit, после того как обновили значение счётчика
	        request.session['last_visit'] = str(datetime.now())
	    else:
	        # установить cookie last visit
	        request.session['last_visit'] = last_visit_cookie
	
	    # Обновить/установить cookie visits
	    request.session['visits'] = visits

Теперь когда мы обновили функцию-обработчик, можно обновить представление `index()`. Сначала измените `visitor_cookie_handler(request, response)` на `visitor_cookie_handler(request)`. Затем добавьте следующую строку, чтобы передать количество посещений в словарь контекста.

{lang="python",linenos=off}
	context_dict['visits'] = request.session['visits']

Убедитесь, что эти строки выполняются до вызова метода `render()` или Ваши изменения не применятся. Представление `index()` должно выглядеть так, как показано ниже. Обратите внимание, что порядок вызова методов отличается, потому что нам больше не нужно изменять cookies в ответе от сервера.

{lang="python",linenos=off}
	def index(request):
	    request.session.set_test_cookie()
	    category_list = Category.objects.order_by('-likes')[:5]
	    page_list = Page.objects.order_by('-views')[:5]
	    context_dict = {'categories': category_list, 'pages': page_list}
	        
	    visitor_cookie_handler(request)
	    context_dict['visits'] = request.session['visits']
	    
	    response = render(request, 'rango/index.html', context=context_dict)
	    return response

Прежде чем перезапустить сервер разработки Django, удалите существующие cookies на стороне клиента. Смотри предупреждение, приведенное ниже, для получения дополнительной информации.

W> ### Избегаем конфликтов c Cookie
W> Настоятельно рекомендуется удалять любые cookies на стороне клиента для Rango *перед* тем как использовать данные, на основе сессий. Это можно сделать через инструменты разработчика Вашего браузера, удалив каждый cookie по отдельности или просто очистить вешь кэш Вашего браузера и убедиться, что все cookies были удалены.

I> ### Типы данных и Cookies
I> Дополнительным преимуществом хранения данных сессии на стороне сервера является возможность приводить данные из строк в требуемый тип. Но эта возможность работает только для [встроенных типов](http://docs.python.org/3/library/stdtypes.html), таких как `int`, `float`, `long`, `complex` и `boolean`. Если вы хотите сохранить словарь или другой сложный тип, то этот способ не сработает. В этом случае можно [сохранять/загружать объекты с помощью модуля Pickle](https://wiki.python.org/moin/UsingPickle).

## Браузерные и постоянные сессии
Используя фреймворк для работы с сессиями Django можно настроить cookies для работы с *браузерными сессиями* или *постоянными сессиями*. Как следует из названий этих двух типов:

-   браузерные сессии заканчиваются, когда пользователь закрывает свой браузер; а
-   постоянные сессии могут длиться на протяжении нескольких сеансов работы с браузером - истекая в момента времени, выбранный Вами. Этот момент может настать через полчаса или даже через месяц.

По умолчанию, браузерные сессии отключены. Вы можете включить их, изменив модуль `settings.py` Вашего Django проекта. Добавьте переменную `SESSION_EXPIRE_AT_BROWSER_CLOSE` и присвойте ей значение `True`.

Постоянные сессии наоборот по умолчанию включены - если `SESSION_EXPIRE_AT_BROWSER_CLOSE` присвоено значение `False` или оно вообще не определено в файле `settings.py` Вашего проекта. Постоянные сессии имеют дополнительную настройку `SESSION_COOKIE_AGE`, которая позволяет определить срок существования cookie. Значение должно быть целым числом, представляющим число секунд существования cookie. Например, если указать в качестве значения `1209600`, то это будет означать, что cookies для Вашего веб сайта истечет через две недели (или 14 дней).

Чтобы узнать больше о доступных параметрах для настройки, которые Вы можете использовать, обратитесь к [официальной Django документации по cookies](https://docs.djangoproject.com/en/2.0/ref/settings/#session-cookie-age). Также можете просмотреть [блог Eli Bendersky](http://eli.thegreenplace.net/2011/06/24/django-sessions-part-i-cookies/), который является прекрасным учебным пособием по cookies и Django.

## Очищаем базу данных сессий
Cookies сессий имеют свойство быстро накапливаться вместе с хранилищем данных, содержащим информацию о сессии. Если Вы используете в качестве бекэнда для Django сессий базу данных, необходимо периодически очищщать её. Это можно сделать с помощью команды `$ python manage.py clearsessions`. В [Django документации](https://docs.djangoproject.com/en/2.0/topics/http/sessions/#clearing-the-session-store) предлагается запускать её ежедневно по расписанию в виде [Cron задачи](https://en.wikipedia.org/wiki/Cron). Если не сделать этого, то производительность Вашего приложения будет уменьшаться по мере роста количества пользователей.

## Выводы и основная последовательность действий
При использовании cookies в Вашем Django приложении, необходимо учитывать, что:

- Во-первых, какой тип cookies необходим для Вашего веб приложения. Должна ли информация храниться на протяжении нескольких сеансов работы пользователя с браузером или её можно спокойно удалить после завершения одного сеанса?
- Тщательно продумайте какую информацию Вы хотите хранить, используя cookies. Помните, что, сохраняя информацию в cookies из их определения следует, что Вы храните её на компьютерах клиентов. Это потенциально огромный риск в плане безопасности: нельзя гарантировать, что компьютер пользователя не взломан. Рассмотрите альтернативы с хранением информации на стороне сервера, если нужно хранить конфиденциальную информацию.
- С учетом предыдущего замечания, помните, что пользователи могут выставить высокий уровень безопасности в своих браузерах, что потенциально может заблокировать Ваши cookies. Из-за этого Ваш сайт может работать не корректно. Вы *должны* предусмотреть этот вариант, поскольку *не можете изменить настройки браузера клиента*.

Если можно использовать cookies на стороне клиента, то осуществите следующие шаги:

1. Проверьте существует ли cookie, который Вам нужен. Для этого проверьте параметр `request`. Функция `request.COOKIES.has_key('<название_cookie>')` возвращает логическое значение, указывающее существует ли cookie с именем `<название_cookie>` на компьютере клиента или нет.
2. Если cookie существует, то Вы можете получить его значение опять с помощью параметра `request` - `request.COOKIES[]`. Атрибут `COOKIES`  является словарем, поэтому внутри квадратных скобок нужно ввести название cookie, который Вы хотите получить в виде строки. Помните, что cookies всегда возвращаются в виде строк, не зависимо от того, что они содержат. Таким образом, возможно Вам нужно будет осуществить приведение к правильному типу (например, с помощью `int()` или `float()`).
3. Если cookie не существует или Вы хотите обновить cookie, передайте значение, которое нужно сохранить объекту `response`. Необходимо вызвать функцию `response.set_cookie('<название_cookie>', value)`, передав два параметра: название cookie и `значение`, которое Вы хотите хранить в нём.

Для повышения безопасности, используйте сессии, основанные на cookies:

1.  Во-первых, убедитесь, что список `MIDDLEWARE_CLASSES` в модуле `settings.py` Вашего Django проекта module содержит `django.contrib.sessions.middleware.SessionMiddleware`. Если нет - добавьте его в список.
2.  Настройте бекэнд для Ваших сессий - `SESSION_ENGINE`. О различных конфигурациях бекэнда можно прочитать в [официальной Django документации по сессиям](https://docs.djangoproject.com/en/2.0/topics/http/sessions/).
3.  Проверьте существует ли cookie с помощью функции `requests.sessions.get()`.
4.  Обновите или установите cookie с помощью словаря сессии, `requests.session['<название_cookie>']`.

X> ### Упражнения
X>
X> После того как Вы прочитали эту главу и поработали с кодом, выполните следующие упражнения.
X> 
X> - Проверьте, что Вы используете cookies на стороне сервера. Очистите кэш браузера и cookies, затем проверьте, что в браузере отсутствуют переменные `last_visit` и `visits`. Обратите внимание, что все равно будет существовать cookie `sessionid`. Django использует этот cookie для поиска сессии в базе данных, где хранятся все серверные cookies, связанные с этой сессией.
X> - Обновите представление для страницы *About* и шаблон, сообщая пользователям, сколько раз они посетили сайт. Не забудьте вызвать `visitor_cookie_handler()` прежде чем попытаетесь получить cookie `visits` из словаря `request.session`, в противном случае, если cookie не установлен, сгенерируется ошибка. 

[^1]: Последняя версия HTTP стандарта HTTP 1.1 на самом деле поддерживает возможность посылки множественных запросов через одно сетевое TCP соединение. Это приводит к значительным улучшениям в производительности, особенно для сетевых соединений с большой задержкой (например, с помощью обычных телефонных модемов и спутников). Это называется *HTTP pipelining* (конвейерная обработка HTTP), о которой можно узнать, прочитав [Википедию](http://en.wikipedia.org/wiki/HTTP_pipelining).