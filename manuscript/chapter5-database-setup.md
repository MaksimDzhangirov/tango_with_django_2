# Модели и базы данных {#chapter-models-databases}
Обычно веб-приложениям требуется серверная часть для хранения динамического содержимого, которое появляется на веб-сайте. Для Rango, нам нужно хранить страницы и категории, а также другую информацию. Чаще всего для этого применяют реляционные базы данных, использующие *язык структурированных запросов (SQL)*. Django, однако, предоставляет удобный способ доступа к данным, хранящимся в базе данных, с помощью [*объектно-реляционного отображения (ORM)*](https://en.wikipedia.org/wiki/Object-relational_mapping). По сути, данные, хранящиеся в таблице базы данных, инкапсулированы с помощью Django *моделей*. Модель - это Python объект, который описывает данные таблицы базы данных. Вместо непосредственной работы с базой через SQL, Django предоставляет методы, которые позволяют вам манипулировать данными через соответствующую модель на языке Python.

В этой главе рассказывается об основах работы с данными, используя Django и его ORM. Вы узнаете, что очень просто добавлять, изменять и удалять данные в базе данных, использующейся в Вашем приложении, и насколько просто передавать данные из базы в браузеры Ваших пользователей.

## Требования приложения Rango {#section-models-databases-requirements}
Прежде чем начать, давайте рассмотрим требования к данным для приложения Rango, которое мы разрабатываем. Полный список требований к приложению был [подробно описан ранее](#overview-er), но чтобы освежить их в памяти, давайте быстро резюмируем требования нашего клиента.

* Rango является по сути *каталогом с веб страницами* - сайтом, содержащим ссылки на другие веб сайты.
* Существует множество различных *категорий с веб страницами* и каждая категория сожержит множество ссылок. [Мы предположили в введении](#overview-er), что это связь один-ко-многим. Смотри [диаграмму сущность-связь ниже](#fig-rango-erd-repeat).
* Категория имеет название, число посещений и количество лайков.
* Страница ссылается на категорию, имеет заголовок, URL и число просмотров.

{id="fig-rango-erd-repeat"}
![Диаграмма сущность-связь для двух основных сущностей Rango.](images/rango-erd.png)

## Сообщаем Django о Вашей базе данных {#section-models-database-telling}
Прежде чем мы сможем создать какие-либо модели, необходимо настроить базу данных в Django. Django автоматически создает переменную `DATABASES` в Вашем модуле `settings.py`, когда Вы начинаете новый проект. Она выглядит примерно следующим образом.

{lang="python",linenos=off}
	DATABASES = {
	    'default': {
	        'ENGINE': 'django.db.backends.sqlite3',
	        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
	    }
	}

Мы можем оставить все как есть для нашего приложения Rango. В качестве базы данных `по умолчанию` выбрана легковесный движок баз данных, [SQLite](https://www.sqlite.org/) (смотри ключ `ENGINE`). Ключ `NAME` для этой базы данных - это путь к файлу базы данных, которым по умолчанию является `db.sqlite3` в корне вашего проекта Django.

> ### Совет для тех, кто использует Git
> Если вы используете Git, у вас может возникнуть желание добавить файл базы данных в репозиторий. Это не очень хорошая идея, потому что, если вы работаете над своим приложением с другими людьми, они могут изменить базу данных, и это вызовет бесконечные конфликты.
>
> Вместо этого добавьте `db.sqlite3` в файл `.gitignore`, чтобы он не добавлялся в репозиторий при `git commit` и `git push`. Вы также можете добавить в `.gitignore` другие файлы, например, `*.pyc` и файлы, генерируемые используемой операционной системой.

> ### Использование других баз данных
> Фреймворк баз данных Django был создан для обслуживания различных баз данных, таких как [PostgresSQL](http://www.postgresql.org/), [MySQL](https://www.mysql.com/) и [Microsoft's SQL Server](https://en.wikipedia.org/wiki/Microsoft_SQL_Server). Для других движков баз данных, существуют другие ключи, например, `USER`, `PASSWORD`, `HOST` и `PORT` позволяющие Вам настроить базу данных в Django.
>
> Хотя в этой книге мы не расскажем как использовать другие движки баз данных, существуют онлайн руководства, в которых показано как это сделать. Хорошей отправной точкой является [официальная документация Django](https://docs.djangoproject.com/en/2.0/ref/databases/#storage-engines).
>
> Обратите внимание, что SQLite достаточно для демонстрации функциональности Django ORM. Когда Ваше приложение станет популярным и будет использоваться тысячами пользователей, Вы можете [перейти на более надёжную базу данных](http://www.sqlite.org/whentouse.html).

## Создание моделей
После настройки Вашей базы данных в `settings.py`, давайте создадим две первые модели данных для приложения Rango. Модели для приложения Django хранятся в соответствующем модуле `models.py`. Это означает, что для Rango модели хранятся в `rango/models.py`.

Для самих моделей мы создадим два класса - по одному классу на модель. Обе должны [наследоваться](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)) от базового класса `Model`, `django.db.models.Model`. Два класса на языке Python будут определять модели, представляющие *категории* и *страницы*. Определите модель `Category` и `Page` следующим образом.

{lang="python",linenos=off}
	class Category(models.Model):
	    name = models.CharField(max_length=128, unique=True)
	    
	    def __str__(self):  
	        return self.name
	
	
	class Page(models.Model):
	    category = models.ForeignKey(Category, on_delete=models.CASCADE)
	    title = models.CharField(max_length=128)
	    url = models.URLField()
	    views = models.IntegerField(default=0)
	
	    def __str__(self):  
	        return self.title

> ### Проверьте наличие команд `import`
> В начале модуля `models.py`, должна быть строка `from django.db import models`. Если она отсутствует - добавьте её.

> ### `__str__()` или `__unicode__()`?
> Методы `__str__()` и `__unicode__()` в Python генерируют строковое представление класса (аналогично методу `toString()` в Java).
> В Python 2.x в методе `__str__()` строки представляются в формате ASCII. Если Вы хотите иметь [поддержку Unicode](https://docs.python.org/2/howto/unicode.html), то Вам нужно также реализовать метод `__unicode__()`.
>
> В Python 3.x строки по умолчанию являются Unicode - поэтому вам нужно только реализовать метод `__str __ ()`.

Когда вы определяете модель, вам нужно указать список полей и связанные с ними типы, а также любые обязательные или дополнительные параметры. По умолчанию все модели имеют целочисленное поле с автоматическим приращением, называемое id, которое назначается автоматически и является первичным ключом.

Django предоставляет [большой набор встроенных типов полей](https://docs.djangoproject.com/es/2.0/ref/models/fields/#model-field-types). Некоторые из наиболее часто используемых подробно описаны ниже.

* `CharField`, поле для хранения символьных данных (например, строк). Укажите `max_length`, чтобы определить максимальное количество символов, которое может хранится в поле.
* `URLField`, очень похож на `CharField`, но предназначен для хранения URL ресурсов. Вы также можете указать параметр `max_length`.
* `IntegerField`, хранит целые числа.
* `DateField`, которое хранит Python объект `datetime.date`.

> ### Другие типы полей
> Просмотрите [Django документацию по полям модели](https://docs.djangoproject.com/es/2.0/ref/models/fields/#model-field-types), чтобы получить полный список полей Django, которые Вы можете использовать, а также информацию об обязательных и необязательных параметрах существующие у каждого.

Для каждого поля Вы можете указать атрибут `unique`. Если он равен `True`, то значение поля должно быть уникально в таблице базы данных, которая связана с соответствующей моделью. Например, взгляните на нашу модель `Category`, определенную выше. Поле `name` имеет атрибут `unique`, таким образом название каждой категории должно быть уникальным. Это означает, что Вы можете использовать это поле как первичный ключ.

Вы также можете указать дополнительные атрибуты для каждого поля, например, указать значение по умолчанию - `default='value'`, указать может ли значение поля быть пустым (или [`NULL`](https://en.wikipedia.org/wiki/Nullable_type)) (`null=True`) или нет (`null=False`).

Django предоставляет три типа полей для определения связей между моделями в Вашей базе данных. А именно:

* `ForeignKey`, тип поля, которое позволяет нам создавать [связь один-ко-многим](https://en.wikipedia.org/wiki/One-to-many_(data_model));
* `OneToOneField`, тип поля, которое позволяет нам определять строгую [связь один-к-одному](https://en.wikipedia.org/wiki/One-to-one_(data_model)); and
* `ManyToManyField`, тип поля, которое позволяет нам определить [связь много-ко-многим](https://en.wikipedia.org/wiki/Many-to-many_(data_model)).

Из наших вышеприведенных примеров для моделей, поле `category` в модели `Page` имеет тип `ForeignKey`. Это позволяет нам создавать связь один-комногим с моделью/таблицей `Category`, которая указана в качестве аргумента конструктору поля. При указании внешнего ключа нам также нужно указать Django как обрабатывать ситуации, когда к которой пренадлежит страница удаляется. `ONCASCADE` указывает Django удалять страницы, связанные с категорией, если категория удаляется. Тем не менее существуют другие настройки, которые позволяют Django по-другому обрабатывать эту ситуацию. Смотри [Django документацию по внешним ключам](https://docs.djangoproject.com/en/2.0/ref/models/fields/#django.db.models.ForeignKey) для получения более подробной информации.

Наконец, хорошей практикой является реализация метода `__str__()`. Если этот метод не реализован, когда вы захотите `вывести` объект, он будет отображаться как `<Category: Category object>`. Эта информация бесполезна при отладке или доступе к объекту - вместо этого приведенный выше код выведет, например, `<Category: Python>` для категории Python. Эта информация также полезна при использовании интерфейса администратора, поскольку Django будет отображать строковое представление объекта.

## Создание и миграция базы данных
После того как наши модели определены в `models.py`, теперь мы можем с помощью магии Django создать таблицы в используемой базе данных. Django предоставляет то, что называется [*инструментом миграций*](https://en.wikipedia.org/wiki/Data_migration) для настройки и обновления базы данных, отражающим любые изменения в Ваших моделях. Например, если вам нужно добавить новое поле, вы можете использовать инструменты миграции для обновления информации в базе данных.

### Настройка базы данных
Прежде всего база данных должна быть *инициализирована*. Это означает создание базы данных и всех связанных с ней таблиц, чтобы затем можно было хранить в них данные. Для этого Вы должны открыть терминал или командную строку и перейти в корневой каталог Вашего проекта, где хранится файл `manage.py`. Выполните следующую команду, но помните, что *вывод может отличаться от того, что показан ниже.*

{lang="text",linenos=off}
	$ python manage.py migrate
	
	Operations to perform:
  		Apply all migrations: admin, auth, contenttypes, sessions
	Running migrations:
		Applying contenttypes.0001_initial... OK
		Applying auth.0001_initial... OK
		Applying admin.0001_initial... OK
		Applying admin.0002_logentry_remove_auto_add... OK
		Applying contenttypes.0002_remove_content_type_name... OK
		Applying auth.0002_alter_permission_name_max_length... OK
		Applying auth.0003_alter_user_email_max_length... OK
		Applying auth.0004_alter_user_username_opts... OK
		Applying auth.0005_alter_user_last_login_null... OK
		Applying auth.0006_require_contenttypes_0002... OK
		Applying auth.0007_alter_validators_add_error_messages... OK
		Applying auth.0008_alter_user_username_max_length... OK
		Applying auth.0009_alter_user_last_name_max_length... OK
		Applying sessions.0001_initial... OK

Все приложения, установленные в вашем Django проекте (просмотрите `INSTALLED_APPS` в `settings.py`) обновят свои представления в базе данных при выполнении этой команды. После выполнения этой команды вы должны увидеть файл `db.sqlite3` в корневом каталоге Django проекта.

Теперь создайте суперпользователя для управления базой данных. Запустите следующую команду.

{lang="text",linenos=off}
	$ python manage.py createsuperuser

Учетная запись суперпользователя будет использоваться для доступа к интерфейсу администратора Django позднее в этой главе. Введите имя пользователя для учетной записи, адрес электронной почты и пароль. После этого скрипт должен успешно завершиться. Обязательно запишите имя пользователя и пароль для вашей учетной записи суперпользователя.

### Создание и обновление моделей/таблиц
Всякий раз когда Вы вносите изменени в модели Вашего приложения, Вам необходимо *зарегистрировать* изменения с помощью команды `makemigrations` в `manage.py`. Если рассматривать в качестве примера приложение `rango`, то нам надо запустить следующую команду из корневого каталога нашего Django проекта.

{lang="text",linenos=off}
	$ python manage.py makemigrations rango
	
	Migrations for 'rango':
		rango/migrations/0001_initial.py
		- Create model Category
		- Create model Page

После выполнения этой команды, перейдите в каталог `rango/migrations` и убедитесь, что был создан скрипт на языке Python. Он называется `0001_initial.py` и содержит всю необходимую информацию для создания схемы базы данных этой конкретной миграции.

> ### Просмотр SQL команд
> Если Вы хотите просмотреть SQL команды, которые Django ORM создало для движка базы данных данной миграции, Вы можете выполнить следующую команду.
>
> {lang="text",linenos=off}
>     $ python manage.py sqlmigrate rango 0001
>
> В этом примере `rango` - это название Вашего приложения, а `0001` - это миграция, SQL код которой Вы хотите просмотреть. Это позволит Вам лучше понять что имено происходит на уровне базы данных, например, какие таблицы создаются. В этих файлах могут создаваться сложные схемы баз данных, в том числе отношение много-ко-многим, для которых создаются дополнительные таблицы.

После того как вы создали миграции для своего приложения, Вам нужно зафиксировать их в базе данных. Сделайте это, выполнив команду `migrate`.

{lang="text",linenos=off}
	$ python manage.py migrate
	
	Operations to perform:
		Apply all migrations: admin, auth, contenttypes, rango, sessions
	Running migrations:
		Applying rango.0001_initial... OK

Такой ответ командной строки подтверждает, что в Вашей базе данных были созданы необходимые таблицы и можно двигаться дальше.

Возможно Вы также заметили, что в нашей модели `Category` в настоящий момент не хватает некоторых полей, которые [были определены в ТЗ для приложения Rango](#section-models-databases-requirements). **Не волнуйтесь, мы добавим их позднее, чтобы напомнить Вам как осуществляется процесс миграций.**

## Django модели и командная оболочка Django
Прежде чем перейти к демонстрации интерфейса администратора, стоит отметить, что Вы можете взаимодействовать с Django моделями из командной оболочки - очень полезный инструмент для отладки. Мы покажем, как создать экземпляр ``Category``, используя его.

Чтобы получить доступ к командной оболочке, необходимо опять вызвать ``manage.py`` из корневого каталога Вашего Django проекта. Выполните следующую команду.

``$ python manage.py shell``

Она запустит экземпляр интерпретатора и загрузит в него настройки Вашего проекта. После этого Вы можете взаимодействовать с моделями, как показано в следующем листинге сессии терминала. Чтобы узнать, что делает каждая команда, прочитайте встроенные комментарии. Обратите внимание, что есть небольшие отличия между тем, что возвращает Django 1.9 и Django 1.10 -- они показаны ниже вместе с комментариями.

{lang="python",linenos=off}

	# Импортируем модель Category из приложения Rango
	>>> from rango.models import Category
	
	# Показать все текущие категории
	>>> print(Category.objects.all())
	# Поскольку не было определено ни одной категории мы получаем пустой QuerySet объект.
	<QuerySet []>  
	
	# Создаем объект новой категории и сохраняем его в базу данных.
	>>> c = Category(name="Test")
	>>> c.save()
	
	# Теперь опять выведем список всех сохраненных объектов категорий
	>>> print(Category.objects.all())
	# Теперь в базе данных сохранена категория под названием 'Test'.
	<QuerySet [<Category: Test>] 
	
	# Выходим из командной оболочки Django.
	>>> quit()

В примере мы сначала импортируем модель, с которой мы хотим работать. Затем мы выводим на экран все существующие категории. Поскольку рассматриваемая таблица `Category` пуста, мы получаем пустой список. Затем мы создаем и сохраняем категорию и опять выводим на экран все категории. Этот второй `print` должен показать только что созданную новую категорию ``Category``. Обратите внимание, что название `Test` появилось во втором `print` - это отработал метод `__str__()`!

> ### Прочитайте официальное пособие
> Вышеприведенный пример очень простой образец тех действий над базой данных, которые Вы можете осуществлять в командной оболочке Django. Если Вы ещё этого не сделали, пора полностью прочитать [вторую часть официального учебного пособия по Django, чтобы узнать больше о взаимодействии с моделями](https://docs.djangoproject.com/en/2.0/intro/tutorial02/). Также ознакомьтесь с [официальной документацией Django, чтобы узнать список доступных команд](https://docs.djangoproject.com/en/2.0/ref/django-admin/#available-commands) для работы с моделями.

## Настраиваем интерфейс администратора
Одной из главных особенностей Django является встроенный веб-интерфейс администрирования (или *администратора*), который позволяет Вам просматривать, редактировать и удалять данные, представленные в виде экземпляров модели (из соответствующих таблиц базы данных). В этом разделе мы настроим интерфейс администратора, чтобы Вы могли работать с двумя моделями Rango, созданными ранее.

Настроить все относительно просто. В модуле `settings.py` Вашего проекта, Вы заметите, что одним из преустановленных приложений (в списке `INSTALLED_APPS`) является `django.contrib.admin`. Кроме того в модуле `urls.py` Вашего проекта есть `url шаблон`, соответствующий `admin/`.

Настроек по умолчанию достаточно для начала работы. Запустите сервер разработки Django как обычно с помощью следующий команды.

{lang="text",linenos=off}
	$ python manage.py runserver

Перейдите в браузере по адресу `http://127.0.0.1:8000/admin/`. Вы увидите интерфейс для входа в систему. Войдите в систему, используя учетные данные, которые вы создали ранее с помощью команды `$ python manage.py createsuperuser`. Затем вы увидите интерфейс [похожий на тот, что показан ниже](#fig-ch5-admin-first).

{id="fig-ch5-admin-first"}
![Интерфейс администратора Django без моделей Rango.](images/ch5-admin-first.png)

Хотя всё выглядит не плохо, нам не хватает моделей `Category` и `Page`, которые были определены для приложения Rango. Чтобы добавить эти модели нам нужно помочь Django.

Для этого откройте файл `rango/admin.py`. Команда `include` для загрузки необходимых моделей уже существует, поэтому измените модуль, *зарегистрировав* в нём каждый класс, который вы хотите добавить. В приведенном ниже примере регистрируются классы `Category` и `Page` в интерфейсе администратора.

{lang="python",linenos=off}
	from django.contrib import admin
	from rango.models import Category, Page
	
	admin.site.register(Category)
	admin.site.register(Page)

Чтобы добавить другие классы, которые могут быть созданы в будущем, просто ещё раз вызовите метод `admin.site.register()`.

После сохранения этих изменений либо перезагрузите страницу интерфейса администратора или перезапустите сервер для разработки Django и снова перейдите по адресу `http://127.0.0.1:8000/admin/`. Теперь Вы увидите модели `Category` и `Page`, [как показано ниже](#fig-ch5-admin-second).

{id="fig-ch5-admin-second"}
![Интерфейс администратора Django с моделями Rango.](images/ch5-admin-second.png)

Попробуйте нажать на ссылку `Categorys` в разделе `Rango`. Там Вы должны увидеть категорию `Test` которую мы создали ранее через командную оболочку Django.

> ### Экспериментируем с интерфейсом администратора
> Вы будете использовать интерфейс администратора для проверки хранения данных при разработке приложения Rango. Поэкспериментируйте с ним и посмотрите, как все это работает. Интерфейс интуитивно понятен и прост.
>
> Удалите категорию `Test`, которая была создана ранее. Мы скоро заполним базу данных тестовыми данными.

> ### Управление учетными записями пользователей
> Интерфейс адинистратора Django - это то место, где Вы можете управлять учетными записями пользователей через раздел Аутентификация и Авторизация. Здесь вы можете создавать, изменять и удалять учетные записи пользователей, а также менять уровни привелегий.

> ### Правильное написание единственного и множественного числа для моделей
>  Обратите внимание на ошибку в названии модели в интерфейсе администратора (`Categorys`, а не `Categories`). Эту ошибку можно исправить, добавив вложенный класс `Meta` в определение Вашей модели с атрибутом `verbose_name_plural`. Просмотрите, например, на модифицированную версию модели `Category`, показанную ниже и [официальную документацию Django по моделям](https://docs.djangoproject.com/en/2.0/topics/db/models/#meta-options) для получения дополнительной информации о том, что может храниться в классе `Meta`.
>
> {lang="python",linenos=off}
> 	class Category(models.Model):
> 	    name = models.CharField(max_length=128, unique=True)
> 	
> 	    class Meta:
> 	        verbose_name_plural = 'Categories'
> 	        
> 	    def __str__(self):
> 	        return self.name

> ### Расширяем `admin.py`
> Следует отметить, что приведенный выше пример настройки модуля ``admin.py`` для Вашего Rango приложения является самым простым рабочим примером из доступных. Вы можете настроить интерфейс администратора различными способами. Для этого ознакомтесь с [официальной документацией Django, посвященной интерфейсу администратора](https://docs.djangoproject.com/en/1.9/ref/contrib/admin/).

## Создание скрипта для заполнения базы данных {#section-models-population}
Ввод тестовых данных в базу данных как правило утомительное занятие. Многие разработчики добавляют некоторые фиктивные тестовые данных, случайно нажимая на клавиши, например `wTFzmN00bz7`. Вместо этого лучше написать скрипт для автоматического заполнения базы данных реалистичными и достоверными данными. Например, когда Вы декомнтрируете или тестируете своё приложение, у Вас будут реалистичные данные в базе данных. Кроме того, если Вы развертываете приложение или делитесь им с соавторами, то Вам/им не придется заново осуществлять процесс ввода тестовых данных. Таким образом, хорошей практикой является создание того, что мы называем *скритпом для заполнения* базы данных.

Чтобы создать скрипт для заполнения базы данных Rango, начнем с создания нового модуля Python в корневом каталоге нашего Django проекта (например, ``<workspace>/tango_with_django_project/``). Создадим файл ``populate_rango.py`` и добавим следующий код.

{lang="python",linenos=on}

	import os
	os.environ.setdefault('DJANGO_SETTINGS_MODULE',
	                      'tango_with_django_project.settings')
	
	import django
	django.setup()
	from rango.models import Category, Page
	
	def populate():
	    # Во-первых, мы создадим списки словарей, содержащих страницы, которые мы хотим добавить в каждую категорию.	    
	    # Затем мы создадим словарь словарей для наших категорий.
	    # Это может показаться немного запутанным, но это позволяет нам перебирать
	    # каждую структуру данных и добавлять данные в наши модели.
	    
	    python_pages = [
	        {"title": "Official Python Tutorial",
	         "url":"http://docs.python.org/2/tutorial/"},
	        {"title":"How to Think like a Computer Scientist",
	         "url":"http://www.greenteapress.com/thinkpython/"},
	        {"title":"Learn Python in 10 Minutes",
	         "url":"http://www.korokithakis.net/tutorials/python/"} ]
	    
	    django_pages = [
	        {"title":"Official Django Tutorial",
	         "url":"https://docs.djangoproject.com/en/1.9/intro/tutorial01/"},
	        {"title":"Django Rocks",
	         "url":"http://www.djangorocks.com/"},
	        {"title":"How to Tango with Django",
	         "url":"http://www.tangowithdjango.com/"} ]
	    
	    other_pages = [
	        {"title":"Bottle",
	         "url":"http://bottlepy.org/docs/dev/"},
	        {"title":"Flask",
	         "url":"http://flask.pocoo.org"} ]
	    
	    cats = {"Python": {"pages": python_pages},
	            "Django": {"pages": django_pages},
	            "Other Frameworks": {"pages": other_pages} }
	    
	    # Если Вы хотите добавить больше категорий или страниц,
	    # включите их в словари выше.
	    
	    # Показанный ниже код перебирает словарь cats, затем добавляет каждую категорию 
	    # и соответствующие страницы для этой категории.	    
	    # Если Вы используете Python 2.x, то используйте cats.iteritems()
	    # смотри http://docs.quantifiedcode.com/python-anti-patterns/readability/
	    # для получения дополнительной информации о том, как правильно перебирать словарь.
	    
	    for cat, cat_data in cats.items():
	        c = add_cat(cat)
	        for p in cat_data["pages"]:
	            add_page(c, p["title"], p["url"])
	    
	    # Print out the categories we have added.
	    for c in Category.objects.all():
	        for p in Page.objects.filter(category=c):
	            print("- {0} - {1}".format(str(c), str(p)))
	
	def add_page(cat, title, url, views=0):
	    p = Page.objects.get_or_create(category=cat, title=title)[0]
	    p.url=url
	    p.views=views
	    p.save()
	    return p
	
	def add_cat(name):
	    c = Category.objects.get_or_create(name=name)[0]
	    c.save()
	    return c
	
	# Код начинает выполняться отсюда!
	if __name__ == '__main__':
	    print("Starting Rango population script...")
	    populate()

> ### Важно понимать этот код!
> **Не нужно просто копировать и вставлять код.** Добавьте код к Вашему новому модулю и затем построчно пройдитесь по нему, чтобы понять что происходит.
> 
> Мы написали пояснения к этому коду ниже, чтобы Вы могли закрепить знаения, поулченные из нашего кода!
>
> Обратите внимание на то, что когда Вы видите номера строк в коде - это означает, что мы приведил листинг всего файла, а не фрагмента. Это также затрудняет простое копирование и вставку кода!

Хотя код кажется большим по существу происходит последовательность вызовов двух небольших функций `add_page()` и `add_cat()`, определенных в конце модуля. Читая код мы видим, что выполнение начинается в *нижней части* модуля - смотри строки 75 и 76. Это связано с тем, что выше мы определяем функции; они не выполнются пока мы не вызовем их. Когда интерпретатор доходит до [`if __name__ == '__main__'`](http://stackoverflow.com/a/419185), мы вызываем функцию `populate()`.

> ### Что означает `__name__ == '__main__'`?
> Трюк с `__name__ == '__main__'` позволяет использовать Python модуль как многократко используемый модуль или отдельный Python скрипт. Под многократно используемым модулем понимается такой, который можно импортировать в другие модули (например, с помощью команды `import`), тогда как отдельный Python скрипт будет выполняться из терминала/командной строки, если ввести `python module.py`.
>
> Таким образом код внутри условного оператора `if __name__ == '__main__'` будет выполняться только тогда, когда модуль запускается как отдельный Python скрипт. При импорте модуля этот код, но тем не менее Вам будут полностью доступны любые классы или функции.

> ### Импортируем модели
> При импорте моделей Django, убедитесь, что Вы импортировали настройки своего проекта, импортировав `django` и определили переменную среды `DJANGO_SETTINGS_MODULE`, присвоив ей значение файла настроек Вашего проекта, как показано в строках 1-6 выше. Затем Вы вызываете ``django.setup()`` для импорта настроек Вашего Django проекта.
>
> Если Вы не выполните этот важный шаг, то **получите исключение при попытке импортировать ваши модели.  Это связано с тем, что необходимая инфраструктура Django еще не инициализирована.** Именно поэтому мы импортируем `Category` и `Page` *после* загрузки настроек в строке 8.

Цикл `for` в строках 51-54 отвечает за многократный вызов функций `add_cat()` и `add_page()`. Эти функции в свою очередь отвечают за создание новых категорий и страниц. `populate()` управляет созданием категорий. Например, ссылка на новую категорию хранится в локальной переменной `c` - смотри строку 52 выше. Она сохраняется поскольку для `Page` требуется ссылка на `Category`. После того как `add_cat()` и `add_page()` вызываются в `populate()`, функция завершается циклическим перебором всех новых объектов `Category` и связанных с ними `Page`, отображая их имена в терминале.

> ### Создаём экземпляры моделей
> Выше в скрипте для заполнения базы мы используем преимущество метода `get_or_create()` при создании моделей. Поскольку мы не хотим создавать дубликаты одной и той же записи, мы можем использовать `get_or_create()`, чтобы проверить существует ли запись в базе данных. Если не существует, метод создаст её. Если существует, то возвращается ссылка на конкретный экземпляр модели.
> 
> Этот вспомогательный метод позволяет не вводить один и тот же код множество раз. Вместо того, чтобы осуществлять эту проверку самим, мы можем использовать код, который делает то же самое за нас.
>
> Метод `get_or_create()` возвращает кортеж `(object, created)`. Первый элемент `object` - это ссылка на экземпляр модели, которая создаётся методом `get_or_create()`, если запись в базе данных не была найдена. Запись создается, используя параметры, которые Вы передаёте методу - точно так же, как `category`, `title`, `url` и `views` в примере выше. Если запись уже существует в базе данных, метод просто возвращает экземпляр модели, соответствующий этой записи. `created` - это логическое значение; True возвращается, если `get_or_create()` пришлось создать экземпляр модели.
>
> Из вышеприведенного объяснения следует, то `[0]` в конце нашего вызова `get_or_create()` возвращает ссылку на объект. Как и в большинстве других языков программирования для структур данных, кортежи Python используют [нумерацию, начинающуюся с нуля.](http://en.wikipedia.org/wiki/Zero-based_numbering).
> 
> Вы можете просмотреть [официальную Django документацию](https://docs.djangoproject.com/en/2.0/ref/models/querysets/#get-or-create), чтобы получить больше информации о вспомогательном методе `get_or_create()`.

После сохранения файла, Вы можете запустить скрипт, изменив текущий рабочий каталог в терминале на корневой каталог Django проекта. В этом случае достаточно выполнить команду ``$ python populate_rango.py``. Вы должны увидеть на экране текст, подобный тому, который показан ниже -- порядок добавления категорий может изменяться в зависимости от настроек вашего компьютера.

{lang="text",linenos=off}

	$ python populate_rango.py
	
	Starting Rango population script...
	- Python - Official Python Tutorial
	- Python - How to Think like a Computer Scientist
	- Python - Learn Python in 10 Minutes
	- Django - Official Django Tutorial
	- Django - Django Rocks
	- Django - How to Tango with Django
	- Other Frameworks - Bottle
	- Other Frameworks - Flask

Теперь давайте убедимся, что скрипт действительно заполнил базу данных. Перезапустите сервер для разработки Django, перейдите в интерфейс администратора (по адресу `http://127.0.0.1:8000/admin/`) и проверьте, что появились новые категории и страницы. Видите ли Вы все страницы, которые изображены на рисунке, если щелкните на `Pages`?

{id="fig-admin-populated"}
![Интерфейс администратора Django, показывающий таблицу `Page`, заполненную новым скриптом. Заполнение прошло успешно!](images/ch5-admin-populated.png)

Хотя создание скрипта для заполнения базы данных может занять некоторое время, в конечном счёте вы сэкономите время. При развертывании приложения на другом компьютере запуск скрипта для заполнения после найстройки проекта позволит Вам сразу начать демонстрацию Вашего приложения. Также он пригодится при модульном [тестировании Вашего кода](#chapter-testing).

## Основная последовательность действий: настройка модели {#section-models-databases-workflow}
Теперь, когда мы рассмотрели основные принципы работы с Django ORM, пора подытожить процессы, необходимые для их настройки. Мы разобьем основные задачи на отдельные части. Возвращайтесь к этому разделу, когда Вам нужно будет освежить в памяти различные шаги в последовательности действий.

### Настраиваем Вашу базу данных
Для нового Django проекта, Вы должны сначала [сообщить Django о базе данных, которую Вы собираетесь использовать](##section-models-database-telling) (т. е., настроить `DATABASES` в `settings.py`). Вы можете также зарегистрировать любые модели в модуле `admin.py` Вашего приложения, чтобы они были доступны через интерфейс администратора. 

### Добавление модели
Последовательность действий для добавления модели может быть разбита на пять этапов.

1. Во-первых, создайте новую модель(и) в файле `models.py` Вашего Django приложения..
2. Отредактируйте `admin.py`, чтобы добавить и зарегистрировать новую модель(и).
3. Затем выполните миграцию `$ python manage.py makemigrations <app_name>`.
4. Подтвердите изменения `$ python manage.py migrate`.Эта команда создаст необходимую инфраструктуру в базе данных для новой модели(ей).
5. Создайте/отредактируйте скрипт для заполнения для новой модели(ей).

Неизбежно возникнут моменты, когда Вам придется удалить базу данных -- иногда проще начать с "чистого листа". В этом случае делайте это следующим образом. Обратите внимание, что в этом учебном пособии Вы используете базу данных SQLite -- но Django поддерживает [множество других движков баз данных](https://docs.djangoproject.com/en/2.0/ref/databases/).

1. Если запущен сервер для разработки Django -- остановите его.
2. Для базы данных SQLite, удалите файл `db.sqlite3` в каталоге Вашего Django проекта. Он будет в том же каталоге, что и файл `manage.py`.
3. Если вы изменили модели своего приложения, вам нужно будет выполнить команду `$ python manage.py makemigrations <app_name>`, заменив `<app_name>` на имя вашего приложения Django (т. е. `rango`). Пропустите этот шаг, если Ваши модели не изменились.
4. Запустите `$ python manage.py migrate`, чтобы создать новый файл базы данных (если вы используете SQLite), и перенесите таблицы в базу данных.
5. Создайте новую учетную запись администратора с помощью команды `$ python manage.py createsuperuser`.
6. Наконец, снова запустите скрипт для заполнения, чтобы вставить реалистичные тестовые данные в новую базу данных.

X> ### Упражнения
X> Теперь, когда Вы прочитали главу, попытайтесь выполнить следующие упражнения, чтобы закрепить и применить на практике то, что вы узнали. ** Опять напоминаем, что в следующих главах подразумевается, что Вы выполнили эти упражнения! Если у Вас что-то не получается, воспользуйтесь подсказками, которые помогут Вам выполнить приведенные ниже упражнения.**
X>
X> * Измените модель `Category` так, чтобы она включала дополнительные атрибуты: `views` и `likes`, у которых значение по умолчанию (`default`) равно нулю (`0`).
X> * Осуществите миграции для Вашего приложения, затем выполните команду `migrate` для Вашей базы данных, чтобы зафиксировать изменения.
X> * Затем отредактируйте скрипт для заполнения так, чтобы категория `Python` имела `128` просмотров и `64` лайка, категория `Django` -- `64` просмотра и `32` лайка и категория `Other Frameworks` -- `32` просмотра и `16` лайков.
X> * Удалите и заново создайте Вашу базу данных, заполнив ее, с помощью обновленного скрипта для заполнения.
X> * Прочтите [вторую](https://docs.djangoproject.com/en/2.0/intro/tutorial02/) и [седьмую](https://docs.djangoproject.com/en/2.0/intro/tutorial07/) части официального учебного пособия по Django. Эти разделы закрепят те знания, которым Вы научились при работе с базами данных в Django, и рассскажут Вам о дополнительных приёмах настройки интерфейса администратора Django.
X> * Настройте интерфейс администратора. Измените его таким образом, чтобы при просмотре модели `Page`, в таблице отображалась категория (`category`), название страницы (`name`) и `url` - так же [как и на скриншоте ниже](#fig-admin-completed). Вам нужно будет выполнить предыдущие упражнения или хотя бы изучить официальное учебное пособие по Django, чтобы выполнить это упражнение.

{id="fig-admin-completed"}
![Обновленный вид страницы интерфейса администратора для модели `Page` с добавленными столбцами для категории и URL.](images/ch5-admin-completed.png)

T> ### Подсказки к упражнениям
T> Если Вам необходима помощью или стимул для выполнения этих упражнений, то мы надеемся, что эти подсказки помогут Вам.
T> 
T> * Измените модель `Category`, добавив два поля `IntegerField`: `views` и `likes`.
T> * Затем в Вашем скрипте для заполнения измените функцию `add_cat()`, чтобы она принимала значения `views` и `likes`.
T> * Вам будет нужно добавить два параметра в определение `add_cat()`, чтобы значения `views` и `likes` могли быть переданы в функцию, а также `name` для категории.
T> * Затем Вы можете использовать эти параметры для изменения значений полей `views` и `likes` нового экземпляра модели `Category`, которую Вы создали в функции `add_cat()`. Экземпляр модели присваивается переменной `c` в скрипте для заполнения, как было определено ранее в этой главе. Например, Вы можете получить доступ к полю `likes`, обращаясь к `c.likes`. Не забудьте сохранить экземпляр!
T> * Затем Вам нужно обновить словарь `cats` в функции `populate()` Вашего скрипта для заполнения. Посмотрите на словарь. Каждая [пара ключ/значение](https://www.tutorialspoint.com/python/python_dictionary.htm) представляет собой *название* категории в качестве ключа и дополнительный словарь, содержащий дополнительную информацию, относящуюся к категории в качестве *значения*. Вы захотите изменить этот словарь, добавив в него `views` и `likes` для каждой категории.
T> * Последний шаг включает в себя изменение способа вызова функции `add_cat()`. Теперь Вам нужно передавать три параметра (`name`, `views` и `likes`); Ваш код в настоящее время предоставляет только `name`. Вам следует добавить два дополнительных аргумента при вызове функции. Если Вы не уверены как работает цикл `for` со словарями, просмотрите [это онлайн-руководство по Python](https://www.tutorialspoint.com/python/python_dictionary.htm). Из него Вы сможете узнать как получить доступ к значениям `views` и `likes` из Вашего словаря.
T> * После того как Ваш скрипт для заполнения был обновлен, Вы можете перейти к изменению интерфейса администратора. Вам нужно отредактировать файл `rango/admin.py` и создать класс `PageAdmin`, который наследуется от `admin.ModelAdmin`.
T> * В Ваш новый класс `PageAdmin`, добавьте `list_display = ('title', 'category', 'url')`.
T> * Наконец, зарегистрируйте класс `PageAdmin` в интерфейсе администратора Django. Вы должны отредактировать строку `admin.site.register(Page)`. Измените её на `admin.site.register(Page, PageAdmin)` в файле `admin.py` Rango.
T> * Если у Вас возникли трудности, просмотрите наш [код на github](https://github.com/leifos/tango_with_django_2/)!

> ### Тесты
>
> Как и в предыдущей главе мы написали тесты, чтобы проверить насколько хорошо Вы освоили материал из этой главы и выполнили упражнения. Для проверки своей работы на данный момент, [загрузите скрипт `tests.py`](https://github.com/leifos/tango_with_django_2/blob/master/code/tango_with_django_project/rango/tests.py) из нашего [GitHub репозитория](https://github.com/leifos/tango_with_django_2/) и сохраните его в каталоге приложения `rango`.
>
> Раскомментируйте тесты, связанные с главой 5.
> Для запуска тестов, введите следующую команду в терминале или командной строке.
>
> {lang="text",linenos=off}
>     $ python manage.py test rango
>
> Если Вас заинтересовали возможности автоматизированного тестирования, сейчас самое время просмотреть [главу, посвященную тестированию](#chapter-testing). В этой главе рассматриваются некоторые основные принципы написания тестов для автоматической проверки целостности вашего кода.
