# Работа с формами {#chapter-forms}
В приложении Rango мы хотим, чтобы у пользователей была возможность создавать новые категории и страницы. Поэтому в этой главе мы рассмотрим процесс сбора данных с помощью веб форм. В Django по умолчанию уже встроен некоторый удобный функционал для обработки форм, что упрощает процесс сбора информации от пользователей и сохранения её в базе данных с помощью моделей. В соответствии с [документацией Django по формам](https://docs.djangoproject.com/en/2.0/topics/forms/), функционал для работы с формами позволяет Вам:

1.  выводить HTML форму с автоматически генерируемыми *виджетами форм* (такими как текстовое поле или поле для выбора даты);
2.  проверять посланные данные, используя набор правил для проверки;
3.  повторно отображать форму в случае ошибок при проверке; а также
4.  преобразовать отправленные данные формы в соответствующие типы данных языка Python.

Одно из главных преимуществ использования Django функционала для работы с формами заключается в большой экономии времени и избавление от рутинной работы по созданию HTML форм. 

## Основная последовательность действий
Ниже приведены основные этапы, необходимые для создания формы и обработки данных, введенных пользователем.

1. Если Вы ещё этого не сделали этого, то создайте файл `forms.py` в каталоге Вашего приложения Django для хранения классов, связанных с формой.
2. Создайте класс `ModelForm` для каждой модели, которая должна быть представлена в виде формы.
3. Настройте форму по Вашему усмотрению.
4. Создайте или измените представление, которое будет обрабатывать данные формы
	 - включая *отображение* формы, 
	 - *сохранение* данных формы, и 
	 - *сигнализацию ошибок*, которые могут возникать, когда пользователь ввел неправильные данные (или вообще не ввел данные) в форму.
5. Создайте или измените шаблон для отображения формы.
6. Добавьте `URL шаблон` для сопоставления новому представлению (если Вы создали новое).

Эта последовательность действий немного сложнее, чем предыдущие, и представления, которые мы будем создавать также гораздо более сложные. Однако, как только Вы повторите процесс несколько раз, Вам станет понятно как всё работает.

## Формы для страницы и категории
Здесь мы реализуем необходимую инфраструктуру, которая позволит пользователям добавлять категории и страницы в базу данных с помощью форм.

Сначала создадим файл под названием `forms.py` в каталоге приложения `rango`. Хотя этот шаг не является обязательным (Вы можете хранить формы в `models.py`), это деляет код чище и с ним проще работать.

### создание классов `ModelForm` {#section-forms-pagecategory-modelform}
В модуле Rango `forms.py` мы создадим несколько классов, которые наследуются от класса Django `ModelForm`. По существу, [`ModelForm`](https://docs.djangoproject.com/en/2.0/topics/forms/modelforms/#modelform) - это *вспомогательный класс*, который позволяет Вам создавать Django `форму` из уже существующей модели. Поскольку у нас уже есть две модели, определенные для Rango (`Category` и `Page`), мы создадим `ModelForms` для обоих.

В `rango/forms.py` добавьте следующий код.

{lang="python",linenos=on}
	from django import forms
	from rango.models import Page, Category
	
	class CategoryForm(forms.ModelForm):
	    name = forms.CharField(max_length=128, 
	                           help_text="Please enter the category name.")
	    views = forms.IntegerField(widget=forms.HiddenInput(), initial=0)
	    likes = forms.IntegerField(widget=forms.HiddenInput(), initial=0)
	    slug = forms.CharField(widget=forms.HiddenInput(), required=False)
	    
	    # Вложенный класс позволяющий задавать дополнительную информацию о форме.
	    class Meta:
	        # Создаем связь между ModelForm и моделью
	        model = Category
	        fields = ('name',)
	
	class PageForm(forms.ModelForm):
	    title = forms.CharField(max_length=128, 
	                            help_text="Please enter the title of the page.")
	    url = forms.URLField(max_length=200, 
	                         help_text="Please enter the URL of the page.")
	    views = forms.IntegerField(widget=forms.HiddenInput(), initial=0)
	    
	    class Meta:
	        # Создаем связь между ModelForm и моделью
	        model = Page
	        
	        # Какие поля мы хотим добавить в нашу форму?
	        # Нам не обязательно добавлять каждое поле, существующее в модели.
	        # Некоторые поля могут иметь значения NULL, поэтому мы не захотим добавлять их...
	        # Здесь мы скрываем внешний ключ.
	        # Мы можем либо исключить поле category из формы
	        exclude = ('category',)
	        # либо указать поля, которые надо в неё добавить (т. е., не добавлять поле category)
	        #fields = ('title', 'url', 'views')

Нам нужно указать какие поля должны быть добавлены в форму с помощью атрибута `fields` или указать какие поля следует исключить с помощью атрибута `exclude`.

Django предоставляет нам несколько способов настройки созданных форм. В вышеприведенном примере кода, мы определили виджеты, которые мы хотим использовать для каждого отображаемого поля. Например, в нашем классе `PageForm` мы определили `forms.CharField` для поля `title` и `forms.URLField` для поля `url`. Оба поля позволяют вводить текстовые данные пользователям. Обратите внимание, что параметры `max_length` , передаваемые нашим полям совпадают с максимальной длиной каждого поля, которые мы определили в моделях данных, лежащих в их основе. Вернитесь к [главе, посвященной моделям](#chapter-models-databases), чтобы освежить информацию в памяти или просмотрите файл Rango `models.py`.

Вы также заметите, что мы добавили несколько `IntegerField`, определяющих количество просмотров и лайков в каждой форме. Заметьте, что мы создали виджет скрытым с параметром `widget=forms.HiddenInput()` и затем установили значение равное нулю с помощью `initial=0`. Это один из способов установить поле равным нулю по умолчанию. И поскольку поля будут скрыты, пользователь не сможет ввести значение для этих полей.

Тем не менее, как видно в `PageForm`, несмотря на то, что у нас есть скрытое поле, нам все равно необходимо добавить поле в форму. Если в `fields` мы исключили `views`, то форма не будет содержать поле (даже если мы его определили) и поэтому форма не будет возвращать нулевое значение для этого поля. Это может привести к ошибке в зависимости от того как была создана модель. Если в моделях мы указали, что `default=0` для этих полей, то мы можем рассчитывать на то, что модель автоматически заполнит поле значением по умолчанию - и таким образом удастся избежать ошибки `not null`. В этом случае, не обязательно задавать эти скрытые поля. Мы также добавили поле `slug` в `CategoryForm` и настроили её, чтобы она использовала `widget=forms.HiddenInput()`, но вместо того, чтобы указывать начальное значение или значение по умолчанию, мы прописали, что поле не требуется для формы. Это связано с тем, что при сохранении формы `save()` наша модель будет отвечать за заполнение этого поля. Это означает, что необходимо быть осторожным при определении Ваших моделей и форм, убеждаясь, что форма содержит и передаёт все данные, которые требуются для правильного заполнения Вашей модели.

Кроме виджетов `CharField` и `IntegerField` доступны и другие для использования. Например, в Django существует `EmailField` (для ввода адреса e-mail), `ChoiceField` (для радиокнопок) и `DateField` (для ввода даты/времени). Существует много других типов полей, которые Вы можете использовать, осуществляющие проверку на ошибки введенных данных за Вас (например, *действительно ли введенное значение является целым числом?*).

Возможно наиболее важной особенностью класса, наследуемого от `ModelForm`, является необходимость определять *для какой модели мы хотим создать форму*. Мы определяем это в нашем вложенном классе `Meta`. Присвойте атрибуту `model` вложенного класса `Meta` модель, которую Вы хотите использовать. Например, наш класс `CategoryForm` содержит ссылку на модель `Category`. Этот важный шаг позволяет Django создать форму на основе указанной модели. Это также поможет при сигнализации любых ошибок, сохранении и отображении данных в форме.

Мы также использовали класс `Meta`? чтобы определить какие поля мы хотим включить в нашу форму с помощью кортежа `fields`. Используйте кортеж c названиями полей, чтобы указать поля, которые Вы хотите в форму.

I> ### Более подробная информация о формах
I>
I> Ознакомтесь с [официальной документацией Django о формах](https://docs.djangoproject.com/en/2.0/ref/forms/) для получения дополнительной информации о различных виджетах и о том, как настраивать формы.

### Создание представления *Добавить категорию (Add Category)* {#section-forms-addcategory}

Теперь когда определен наш класс `CategoryForm`, мы готовы создать новое представление для отображения формы и обработки введенных в форму данных. Для этого добавьте следующий код в `rango/views.py`.

{lang="python",linenos=off}
	# Добавьте этот импорт в начало файла
	from rango.forms import CategoryForm
	...
	def add_category(request):
	    form = CategoryForm()
	    
	    # HTTP POST?
	    if request.method == 'POST':
	        form = CategoryForm(request.POST)
	        
	        # Все поля формы были заполнены правильно?
	        if form.is_valid():
	            # Сохранить новую категорию в базе данных.
	            form.save(commit=True)
	            # Теперь, когда категория сохранена
	            # Мы могли бы выдать подтверждающее сообщение
	            # Но поскольку последня добавленная категория находится на странице index,
	            # то мы можем перенаправить пользователя обратно на страницу index.
	            return index(request)
	        else:
	            # Обрабатываемая форма содержит ошибки -
	            # просто выводим их в терминал.
	            print(form.errors)
	    
	    # Обработка ситуаций, когда форма содержит неправильную информацию, когда нужно вывести новую форму или когда форма не была получена.
	    # Вывести форму с сообщениями об ошибках (если они были).
	    return render(request, 'rango/add_category.html', {'form': form})

Новое представление `add_category()` добавляет несколько ключевых элементов функциональности для обработки форм. Во-первых, мы создаём CategoryForm(), затем проверяем был ли HTTP метод запроса `POST`,т. е. отправлял ли пользователь данные через форму. Затем мы можем обработать `POST` запрос приходящий на тот же URL-адрес. Функция-представление `add_category()` может работать в трех различных режимах:

- показывать новую, пустую форму для добавления категории;
- сохранять данные формы, введенные пользователем в соответствующую модель, и выдавать главную страницу Rango; и
- если возникли ошибки, повторно отображать форму с сообщениями об ошибках.

I> ### `GET` и `POST`
I>
I> Что мы имеем в виду под  `GET` и `POST`? Существует два различных типа *HTTP запросов*.
I>
I> - HTTP `GET` используется для *запроса содержимого указанного ресурса.* Другими словами, мы используем HTTP `GET` для получения конкретного ресурса, например, веб страницы, изображения или другого файла.
I> - Напротив, HTTP `POST` *применяется для передачи данных веб браузера клиента.* Этот тип запроса используется, например, при отправке содержимого HTML формы.
I> - Наконец, HTTP `POST` может использоваться для создания нового ресурса (например, новой записи в базе данных) на сервере. В дальнейшем к ней можно получить доступ через HTTP `GET` запрос.
I> - Посетите [w3schools страницу `GET` vs. `POST`](http://www.w3schools.com/tags/ref_httpmethods.asp) для получения более подробной информации.

Механизм обработки форм Django обрабатывает данные, возвращаемые из браузера пользователя, через HTTP `POST` запрос. Он не только обрабатывает сохранение данных формы в выбранную модель, но также автоматически генерирует любые сообщения об ошибках для каждого поля формы (если они необходимы). Это означает, что Django не будет сохранять отправленные формы с отсутствующей информацией, что может потенциально привести к проблемам [ссылочной целостности](https://en.wikipedia.org/wiki/Referential_integrity) Вашей базы данных. Например, если не ввести значение в поле с названием категории, то это приведет к ошибке, так как поле не может быть пустым.

Обратите внимание, что в строке, где мы вызываем `render()`, мы ссылаемся на новый шаблон с именем `add_category.html`. Он будет содержать соответствующий код шаблона Django и HTML-код для формы и страницы.

### Создание шаблона *Добавить категорию (Add Category)*
Создайте файл `templates/rango/add_category.html`. В файл добавьте следующую HTML разметку и код шаблона Django.

{lang="html",linenos=on}
	<!DOCTYPE html>
	<html>
	    <head>
	        <title>Rango</title>
	    </head>
	    
	    <body>
	        <h1>Add a Category</h1>
	        <div>
	            <form id="category_form" method="post" action="/rango/add_category/">
	                {% csrf_token %}
	                {% for hidden in form.hidden_fields %}
	                    {{ hidden }}
	                {% endfor %}
	                {% for field in form.visible_fields %}
	                    {{ field.errors }}
	                    {{ field.help_text }}
	                    {{ field }}
	                {% endfor %}
	                <input type="submit" name="submit" value="Create Category" />
	            </form>
	        </div>
	    </body>
	</html>

Как видно из кода, внутри тега `<body>` HTML страницы мы поместили элемент `<form>`. Посмотрев на атрибуты элемента `<form>` видно, что все данные, введенные в эту форму, будут отправляться на URL `/rango/add_category/` в виде HTTP POST запроса (атрибут `method` не чувствителен к регистру, поэтому Вы можете ввести `POST` или `post` - что приведет к одному и тому же результату). Внутри формы выполняются два цикла:

- один для *скрытых* полей формы, а
- другой для *видимых* полей формы.

Видимые поля, то есть те, которые будут отображаться пользователю, задаются атрибутом `fields` вложенного класса `Meta` Вашего класса `ModelForm`. Эти циклы создают HTML разметку для каждого элемента формы. Для видимых полей формы мы также добавляем любые ошибки, которые могут возникать для конкретного поля и вспомогательный текст, который может использоваться, чтобы объяснить пользователю, что он или она должны ввести.

I> ### Скрытые поля
I> Необходимость скрытых и видимых полей обусловлена тем, что HTTP - это протокол, не сохраняющий своего состояния. Вы не можете сохранять состояние между различными HTTP-запросами, что может усложнить реализацию определенных частей веб приложений. Для решения этой проблемы, создаются скрытые поля HTML формы, которые позволяют веб приложениям передавать важную информацию клиенту (не видимую на выдаваемой странице) в HTML форме, только чтобы послать её обратно серверу, когда пользователь отправит форму.

I> ### Токены защиты от межсайтовой подделки запроса
I> Также обратите внимание на фрагмент кода `{% csrf_token %}`. Это *токен защиты от межсайтовой подделки запроса*, который используется для защиты и безопасного HTTP  `POST` запроса, который создается после отправки данных формы. *CSRF токен является обязательной составляющей форм для фреймворка Django. Если Вы забудете добавить CSRF токен в свои формы, у пользователя могут возникнуть ошибки при отправке формы*. Ознакомьтесь с [официальной документацией Django по CSRF токенам](https://docs.djangoproject.com/en/2.0/ref/csrf/) для получения дополнительной информации об этом.

### Сопоставление URLа представлению *Добавить категорию (Add Category)*
Теперь необходимо сопоставить представлению `add_category()` URL. В шаблоне мы использовали URL `/rango/add_category/` в атрибуте `action` формы. Теперь нам нужно создать сопоставление для представления, используя этот URL. В `rango/urls.py` измените `urlpatterns` следующим образом:

{lang="python",linenos=off}
	urlpatterns = [
    	path('', views.index, name='index'),
     	path('about/', views.about, name='about'),
     	path('category/<slug:category_name_slug>/', views.show_category, name='show_category'),
	    path('add_category/', views.add_category, name='add_category'),
	   
	]

Порядок шаблонов не имеет значения в этом случае. Тем не менее, просмотрите официальную [Django документацию о том как Django обрабатывает запрос](https://docs.djangoproject.com/en/2.0/topics/http/urls/#how-django-processes-a-request) для получения дополнительной информации. URL для добавления категории - это `/rango/add_category/`.

<!--BREAK-->

### Изменение внешнего вида главной страницы
Наконец, давайте поместим ссылку на главной странице, чтобы мы могли легко добавлять категории. Отредактируйте шаблон 
`rango/index.html` и добавьте следующую HTML гиперссылку в `<div>` элемент с ссылкой на страницу `about`.

{lang="html",linenos=off}
	<a href="/rango/add_category/">Add a New Category</a><br />
	
### Пример работы
Теперь давайте проверим работоспособность написанного кода! Запустите или перезапустите сервер для разработки Django, и перейдите по адресу `http://127.0.0.1:8000/rango/`. Используйте Вашу новую ссылку, чтобы перейти на страницу добавления категории и попытайтесь добавить категорию. На [рисунке ниже](#fig-ch7-add-cat) скриншоты страниц "Добавить категорию" и "Главной страницы".

{id="fig-ch7-add-cat"}
>![Добавляем новую категорию в Rango с помощью нашей новой формы.](images/ch7-add-cat.png)

I> ### Отсутствующие категории
I> Если Вы добавите несколько категорий, они не всегда будут отображаться на главной странице. Это связано с тем, что показываем только пять первых категорий на главной странице. Если Вы войдёте в интерфейс администратора, то сможете просмотреть все категории, которые Вы ввели.
I> 
I> Другой способ проверить, что категория была добавлена - обновить метод `add_category()` в `rango/views.py` и 
изменить строку `form.save(commit=True)` на `cat = form.save(commit=True)`. В переменной `cat` будет храниться ссылка на экземпляр объекта категории, созданной формой. После этого Вы можете вывести категорию в консоль (например, `print(cat, cat.slug)`).

### Проверяем данные формы
Вспомним, что наша модель `Page` имеет атрибут `url`, который является экземпляром типа `URLField`. В соответствующей HTML форме, Django будет ожидать, что текст введенный в поле `url` будет правильно отформатированным, полным URL. Однако пользователи могут полениться вводить что-то на подобии `http://www.url.com` - на самом деле пользователи [могут даже не знать, что должен включать в себя правильный URL](https://support.google.com/webmasters/answer/76329?hl=en)!

I> ### Проверка URL
I> Большинство современных браузеров теперь проверяют правильность URL-адреса, поэтому этот пример будет работать только в старых браузерах. Тем не менее, он показывает, как отфильтровать данные прежде чем пытаться сохранить их в базе данных. Если у вас нет старого браузера, чтобы проверить работу этого примера (если Вы не верите нам), попробуйте изменить `URLField` на `CharField`. Генерируемый HTML-код теперь не будет указывать браузеру осуществлять проверку и выполнится код, который Вы реализовали.

В случае, когда ввод от пользователя может быть не правильным, мы можем *переопределить* метод `clean()` в `ModelForm`. Этот метод вызывается перед сохранением данных формы в новый экземпляр модели и таким образом является логическим местом для вставки кода, который может проверить - и даже исправить - любые данные, которые пользователь ввел в форму. Мы можем проверить начинается ли значение, введенное пользователем в поле `url` с `http://` - и если нет - вставить `http://` перед значением введенным пользователем.

{lang="python",linenos=off}
	class PageForm(forms.ModelForm):
	    ...
	    def clean(self):
	        cleaned_data = self.cleaned_data
	        url = cleaned_data.get('url')
	        
	        # Если url не пустое и не начинается с 'http://', 
	        # вставить перед ним 'http://'.
	        if url and not url.startswith('http://'):
	            url = 'http://' + url
	            cleaned_data['url'] = url
	            
	            return cleaned_data

Простую последовательность действий внутри метода `clean()` Вы можете повторить в своей собственной реализации кода обработки Django форм.

1. Данные формы берутся из атрибута-словаря `cleaned_data` класса `ModelForm` dictionary attribute `cleaned_data`.
2. После этого поля формы, которые Вы хотите проверить на правильность ввода, могут быть извлечены из словаря `cleaned_data`. Используйте `.get()` метод объекта словаря, чтобы получить значения формы. Если пользователь не ввел значение в поле формы, его не будет существовать в словаре `cleaned_data`. В этом случае метод `.get()` вернет `None`, а не вызовет исключение `KeyError`. Это упростит Ваш код!
3. Проверьте, что для каждого поля формы, которое Вы хотите обработать, было получено значение. Если что-то было введено, проверьте что именно. Если это не то, что Вы ожидаете, добавьте логику для исправления этой ошибки, прежде чем переопределить значение в словаре `cleaned_data` для данного поля.
4. Вы *всегда должны* заканчивать метод `clean()`, возвращая ссылку на словарь `cleaned_data`. в противном случае, внесенные изменения не сохранятся.

Этот простой пример показывает, как мы можем проверить данные, передаваемые с помощью формы, перед тем как сохранить их. Это очень удобно, особенно, когда определенные поля должны иметь значения по умолчанию - или в форме отсутствуют данные и поэтому нам необходимо решать такие проблемы с введенными данными.

I> ### Переопределение метода Clean
I> Переопределение методов, реализуемое в рамках фреймворка Django является элегантным способом придать Вашему приложению дополнительные функциональные возможности. Существует множество методов, которые Вы можете безопасно и с выгодой переопределить, например, метод `clean()` в классе `ModelForm`, как показано выше. Просмотрите [официальную Django документацию по моделям](https://docs.djangoproject.com/en/2.0/topics/db/models/#overriding-predefined-model-methods) где приведено больше примеров о том, как Вы можете переопределить функционал, реализуемый по умолчанию, своим собственным.

X> ### Упражнения
X> Теперь, когда Вы ознакомились с материалом этой главы, прочитайте следующие вопросы и подумайте как бы Вы ответили на них.
X> 
X> - Что произойдет, если Вы не введете название категории в форму для добавления категории?
X> - Что произойдет, если Вы попытаетесь добавить категорию. которая уже существует?
X> - Что произойдет, если Вы перейдете по адресу категории, которой не существует? Подсказка для потенциального решения этой проблемы приведена ниже.
X> - В [разделе, где мы реализовали наши классы `ModelForm`](#section-forms-pagecategory-modelform), мы повторно вводили значения `max_length` для полей, которые ранее определили в [главе, посвященной моделям](#chapter-models-databases). Это плохая практика, поскольку мы *дублируем код*! Как можно реорганизовать этот код, чтобы *не* повторять ввод значений `max_length`?
X> - Если Вы этого еще не сделали, прочитайте четвертую часть [официального учебного пособия по Django](https://docs.djangoproject.com/en/2.0/intro/tutorial04/), чтобы закрепить то, чему Вы здесь научились.
X> - Теперь реализуйте функционал, позволяющий пользователям добавять страницы в каждую категорию, смотри ниже примеры кода и подсказки к упражнениям.

### Создание представления *Добавить стриницы* (Add Pages), шаблона и сопоставление URLа представлению {#section-forms-addpage}
Следующий логический шаг - позволить пользователям добавлять страницы в заданную категорию. Для этого повторите вышеприведенную последовательность действий, но в этот раз для добавления страниц.

- создайте новое представление, `add_page()`, 
- создайте новый шаблон, `rango/add_page.html`, 
- добавьте URL сопоставление и
- обновите страницу категории/представление, добавив ссылку на функционал для добавления страницы на страницу категории.

Чтобы помочь Вам, ниже показан код фукнции-представления `add_page()`.

{lang="python",linenos=off}
	from rango.forms import PageForm

	def add_page(request, category_name_slug):
	    try:
	        category = Category.objects.get(slug=category_name_slug)
	    except Category.DoesNotExist:
	        category = None
	    
	    form = PageForm()
	    if request.method == 'POST':
	        form = PageForm(request.POST)
	        if form.is_valid():
	            if category:
	                page = form.save(commit=False)
	                page.category = category
	                page.views = 0
	                page.save()
	                return show_category(request, category_name_slug)
	        else:
	            print(form.errors)
	    
	    context_dict = {'form':form, 'category': category}
	    return render(request, 'rango/add_page.html', context_dict)


T> ### Подсказки к упражнениям
T> Следующие подсказки могут помочь Вам при решении вышеприведенных упражнений.
T>
T> - В шаблоне `add_page.html` Вы можете получить доступ к slug с помощью ``{{ category.slug }}``, поскольку представление передает объект `category` в шаблон через словарь контекста.
T> - Убедитесь, что ссылка появляется только тогда, когда *запрошенная категория существует* - со страницами или без, т. е. в шаблоне проверяйте `{% if cat %} .... {% else %} Категории с таким именем не существует {% endif %}`.
T> - Обновите шаблон Rango `category.html`, добавив новую гиперссылку с разрывом строки: `<a href="/rango/category/{{category.slug}}/add_page/">Add Page</a> <br/>`
T> - Убедитесь, что в Вашем шаблоне `add_page.html` форма отправляет данные по адресу `/rango/category/{{ category.slug }}/add_page/`.
T> - Обновите `rango/urls.py`, добавив URL сопоставление (`/rango/category/<category_name_slug>/add_page/`) для обработки вышеприведенной ссылки.
T> - Вы можете избежать повторения параметров `max_length`, используя дополнительный атрибут в Вашем классе `Category`. В этом атрибуте можно хранить значение для `max_length`, а затем при необходимости на него ссылаться.
T>
T> Если у Вас *действительно* возникли трудности при выполнении упражнений, Вы всегда можете просмотреть [наш код на GitHub](https://github.com/leifos/tango_with_django_2).