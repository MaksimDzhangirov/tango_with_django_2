# Работа с шаблонами {#chapter-templates-extra}
Ранее мы создали несколько HTML шаблонов для различных страниц в нашем приложении Rango. Создавая каждый дополнительный шаблон, вы, возможно, заметили, что большая часть HTML-кода повторяется. Каждый раз, когда вы повторяете код, вы нарушаете [DRY принцип](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), который формулируется как: НЕ ПОВТОРЯЙСЯ!. Возможно, Вы также заметили, что мы ссылались на разные страницы, используя жестко прописанные URL пути. Это плохая практика - имена всегда будут меняться.
Вместе повторяющийся код и жесткое кодирование приведут к проблемам сопровождения кода, поскольку если мы захотим внести изменения в общую структуру сайта или изменить URL путь, Вам придется изменить все шаблоны, в которых есть этот URL или где используется эта структура. Это может не казаться большой проблемой, если Ваш сайт состоит из нескольких страниц, но подумайте, что если бы Ваш сайт имел сотни или миллионы - сколько бы времени это заняло? Насколько вероятны ошибки?
К счастью для нас, разработчики Django уже подумали о том, как решить такие проблемы и предложили решения. В этой главе мы будем использовать *наследование шаблонов* для решения первой проблемы и *URL тэг шаблона* для решения второй проблемы. В первую очередь мы решим вторую проблему.
## Использование относительных URL в шаблонах
До сих пор мы непосредственно прописывали URL-адрес страницы или представления, который мы хотим показать в шаблоне, т. е. `<a href="/rango/about/">About</a>`. Такое жесткое кодирование URL-адресов означает, что если мы изменим наши URL сопоставления в `urls.py`, то нам также придется изменить все эти URL ссылки. Предпочтительней использовать тэг шаблона `url` для поиска URL в файлах `urls.py` и динамической подстановки URL путей.
Довольно просто добавить относительные URL в Ваши шаблоны. Чтобы сослаться на страницу *About*, мы вставили следующую строку в наши шаблоны:

{lang="html",linenos=off}
	<a href="{% url 'about' %}">About</a>

Механизм обработки шаблонов Django просмотрит все модули `urls.py` в поиске URL шаблона с атрибутом `name` равным `about` (`name='about'`) и затем сопоставит ему фактический URL. Это означает, что если мы изменим URL сопоставления в `urls.py`, то не нужно будет просмотреть все шаблоны и обновить адреса URL в них.
Мы также можем ссылаться на URL шаблон без определенного названия, используя непосредственно представление как показано ниже.

{lang="html",linenos=off}
	<a href="{% url 'rango.views.about' %}">About</a>

В этом примере мы должны быть уверены, что приложение `rango` имеет представление `about`, хранящееся в модуле `views.py`.

В шаблоне `index.html` Вашего приложения Вы видели параметризованный URL шаблон (`show_category` URL/представление принимает в качестве параметра `category.slug`). В этом случае Вы можете передать тэгу шаблона `url` название URL/представления и slug следующим образом:

{lang="html",linenos=off}
	{% for category in categories %}
	    <li>
	        <a href="{% url 'show_category' category.slug %}">
	            {{ category.name }}
	        </a>
	    </li>
	{% endfor %}

Прежде чем Вы начнете обновлять все URL-адреса во всех ваших шаблонах с помощью относительных URL-адресов, нам нужно реструктурировать и реорганизовать наши шаблоны, используя наследование для удаления повторений.
T> ### URL-адреса и несколько приложений Django
T> Эта книга посвящена разработке одного приложения Django, Rango. Однако Вы можете работать над проектом Django с несколькими приложениями, которые используются одновременно. Это означает, что у Вас может быть сотня потенциальных URLов, для которых Вам можете понадобиться ссылка. В этом случае возникает вопрос *как мы можем организовать работу с этими URL-адресами*? У двух приложений может быть одно и то же имя, что может привести к потенциальному конфликту.
T>
T> [Django позволяет использовать *пространства имен* при настройке URL модулей](https://docs.djangoproject.com/en/2.0/topics/http/urls/#url-namespaces) (e.g. `urls.py`) для каждого отдельного приложения, которое Вы используете в своём проекте. Достаточно просто добавить переменную `app_name` в модуль `url.py` Вашего приложения. В примере ниже определяется пространство имен для приложения Rango app с названием `rango`.
T>
T> {lang="python",linenos=off}
T> 	from django.conf.urls import url
T> 	from rango import views
T> 	
T> 	app_name = 'rango'
T> 	urlpatterns = [
T>	    path('', views.index, name='index'),
T>    	path('about/', views.about, name='about'),
T>    	path('category/<slug:category_name_slug>/add_page/', 
T>			views.add_page, name='add_page'),
T>	    ...
T> 	]
T>
T> Добавление переменной `app_name` означает, что ссылку на любой URL из приложения `rango` можно получить следующим образом:
T>
T> {lang="html",linenos=off}
T> 	<a href="{% url 'rango:about' %}">About</a>
T> 
T> где двоеточие в `url` команде разделяет пространство имен от URL имени.
T> Несмотря на то, что пространство имен необходимо только при наличии нескольких приложений - о нём знать, особенно в случае, если проект будет разростаться.

## Боримся с повторениями кода
Хотя почти каждый профессионально создаваемый веб-сайт, который Вы используете, имеет ряд повторяющихся элементов (например, хедер, сайдбар и футер), повторять HTML-код каждого из этих элементов не разумно. Что если Вы захотите изменить часть хедера Вашего веб-сайта? Вам нужно было бы отредактировать *каждую* страницу и изменить каждую копию хедера. Это может занять много времени и всегда существует вероятность человеческой ошибки.

Вместо траты времени на копирование и вставку HTML разметки, мы можем минимизировать повторения в коде Rango, используя *наследование шаблонов*, предоставляемое языком шаблонов Django.

Основной принцип наследования шаблонов заключается в следующем:

1.  Определить повторяющиеся части на каждой странице для Вашего приложения (т. е., хедер, сайдбар, футер, элементы внутри основного содержимого страницы). Иногда полезно на бумаге нарисовать базовую структуру Ваших различных страниц, чтобы определить какие компоненты, используются на нескольких страницах.
2.  В *базовом шаблоне* создать каркас стандартной страницы, добавив в него любые общие элементы (т. е., авторские права в футере, логотип и название, которые обычно располагаются в хедере). Затем определите *блоки*, которые будут меняться в зависимости от просматриваемой пользователем страницы.
3. Создайте конкретные шаблоны для страниц Вашего приложения - наследуемые от базового шаблона - и укажите содержимое для каждого блока.

### Повторяющийся HTML код и базовый шаблон
В ранее созданных шаблонах мы повторяли очень много HTML-кода. Ниже мы абстрагируемся от деталей, характерных для конкретных страниц, чтобы показать каркас, который будет повторяться в каждом шаблоне.

{lang="html",linenos=on}
	<!DOCTYPE html>
	{% load staticfiles %}
	
	<html>
	    <head lang="en">
	        <meta charset="UTF-8" />
	        <title>Rango</title>
	    </head>
	    <body>
	        <!-- Содержимое характерное для каждой конкретной страницы будет располагаться здесь. -->
	    </body>
	</html>

Для начала пусть эта простая HTML страница будет базовым шаблоном нашего приложения. Сохраните эту разметку в `base.html` в каталоге `templates/rango/` (например, `templates/rango/base.html`).

W> ### `DOCTYPE` всегда должен быть на первой строке!
W>
W> Помните, что объявление `<!DOCTYPE html>` *всегда должно размещаться на первой строке* Вашего шаблона.
W> Отсутствие [объявления типа документа](https://en.wikipedia.org/wiki/Document_type_declaration) в первой строке приведет к тому, что получившаяся страница, созданная на основе Вашего шаблона, не будет соответстовать [рекомендациям W3C HTML](https://www.w3.org/standards/webdesign/htmlcss).

### Шаблоны блоков
Теперь когда мы создали наш базовый шаблон мы можем добавить теги шаблона, чтобы указать какие части шаблона могут быть переопределены шаблонами, которые наследуются от него. Для этого мы будем использовать тег `block`. Например, мы можем добавить `body_block` к базовому шаблону в `base.html` следующим образом:

{lang="html",linenos=on}
	<!DOCTYPE html>
	{% load staticfiles %}
	
	<html>
	    <head lang="en">
	        <meta charset="UTF-8" />
	        <title>Rango</title>
	    </head>
	    <body>
	        {% block body_block %}
	        {% endblock %}
	    </body>
	</html>

Напомним, что стандартные команды шаблона Django обозначаются тэгами `{%` и `%}`. Чтобы начать блок используется команда `{% block <NAME> %}`, где `<NAME>` - это название блока, который Вы хотите создать. Вы также должны убедиться, что закрыли блок командой `{% endblock%}`, снова заключенной в теги шаблонов Django.

Вы также можете указать *содержимое по умолчанию* для своих блоков, которое будет использоваться, если никакой наследующий шаблон не переопределяет данный блок (смотри [ниже](#section-templates-inheritance)). Для задания содержимого по умолчанию добавьте HTML разметку между командами `{% block %}` и `{% endblock %}` как в примере ниже.

{lang="html",linenos=off}
	{% block body_block %}
	    This is body_block's default content.
	{% endblock %}

Когда мы будем создавать шаблоны для каждой страницы мы будем наследоваться от `rango/base.html` и перезаписывать содержимое `body_block`. Вы можете разместить в своих шаблонах столько блоков, сколько пожелаете. Например, вы можете создать блок для заголовка страницы, блок для нижнего колонтитула, блок для боковой панели и т. д.. Блоки - действительно мощный инструмент системы шаблонов Django и вы можете узнать больше о них, ознакомившись из [официальной документацией Django по шаблонам](https://docs.djangoproject.com/en/1.9/topics/templates/).

I> ### Извлекаем повторяющиеся структуры
I>
I> Вы всегда должны стремиться извлечь как можно больше повторяющегося контента из своих базовых шаблонов. Хотя на это может уйти много времени, время, которое Вы сэкономите на техническом обслуживании значительно превысит первоначальное, затраченное на это.
I>
I> *Сделать это не всегда легко, но это лучше, чем тратить время на ежедневную, рутинную работу!*

### Дальнейшее абстрагирование
Теперь, когда Вы имеете представление о блоках в шаблонах Django, давайте ещё больше абстрагируем наш базовый шаблон. Заново откройте шаблон `rango/base.html` и измените его, чтобы он выглядел следующим образом.

{lang="html",linenos=on}
	<!DOCTYPE html>
	{% load staticfiles %}
	
	<html>
	    <head>
	        <title>
	            Rango - 
	            {% block title_block %} 
	               - How to Tango with Django!
	            {% endblock %}
	        </title>
	    </head>
	    <body>
	        <div>
	            {% block body_block %}
	            {% endblock %}
	        </div>
	        <hr />
	        <div>
	            <ul>
	                <li><a href="{% url 'add_category' %}">Add New Category</a></li>
	                <li><a href="{% url 'about' %}">About</a></li>
	                <li><a href="{% url 'index' %}">Index</a></li>
	            </ul>
	        </div>
	    </body>
	</html>

В этом примере мы ввели два новых элемента в базовый шаблон.

-   Во-первых - блок шаблона под названием `title_block`. Он позволяет нам указать разный заголовок для каждой страницы, наследуемой от нашего базового шаблона. Если наследуемая страница не изменит этот блок, то `title_block` будет использовать значение по умолчанию `How to Tango with Django!`, что приведет к тому, что заголовок страницы примет вид `Rango - How to Tango with Django!`. Посмотрите на содержимое тега `<title>` в приведенном выше шаблоне, чтобы понять как это работает.
- Мы также добавили список ссылок из нашего текущего шаблона `index.html` и поместили его в HTML тег `<div>` ниже нашего блока `body_block`. Это гарантирует наличие ссылок на всех страницах, которые наследуются от базового шаблона. Перед ссылками размещается *горизонтальная линия* (`<hr />`), которая визуально разделяет для пользователя содержимое блока `body_block` и ссылками.

## Наследование шаблонов {#section-templates-inheritance}
Теперь, когда мы создали базовый шаблон с блоками, мы можем обновить все ранее созданные шаблоны, так, чтобы они наследовались от базового. Давайте модифицируем шаблон `rango/category.html`.

Для этого сначала удалите весь повторяющийся HTML код, оставив только HTML и команды/теги шаблона, характерные для этой страницы. Затем в начале шаблона добавьте следующую строку кода:

{lang="html",linenos=off}
	{% extends 'rango/base.html' %}

Команда `extends` принимает один параметр - шаблон, который будет расширен/унаследован (т. е., `rango/base.html`). Путь к шаблону, который Вы передаете команде `extends`, должен задаваться относительно каталога `templates` Вашего проекта. Например, все шаблоны, которые мы используем для Rango должны наследоваться от `rango/base.html`, а не `base.html`. Затем мы ещё изменим шаблон `category.html`, чтобы он выглядел как в следующем примере.

{lang="html",linenos=on}
	{% extends 'rango/base.html' %}
	{% load staticfiles %}
	
	{% block title_block %}
	   {{ category.name }}
	{% endblock %}
	
	{% block body_block %}
	    {% if category %}
	        <h1>{{ category.name }}</h1>
	        
	        {% if pages %}
	            <ul>
	            {% for page in pages %}
	                <li><a href="{{ page.url }}">{{ page.title }}</a></li>
	            {% endfor %}
	            </ul>
	        {% else %}
	            <strong>No pages currently in category.</strong>
	        {% endif %}
	        <a href="{% url 'add_page' category.slug %}">Add a Page</a>
	    {% else %}
	        The specified category does not exist!
	    {% endif %}
	{% endblock %}

W> ### Загрузка `staticfiles`
W> Вам нужно убедиться, что вы добавили `{% load staticfiles %}` в начало **каждого шаблона**, где используются статические медиа файлы. Если вы этого не сделаете, это приведёт к ошибке! Шаблонные модули Django должны импортироваться индивидуально для каждого шаблона, который их требует. Если Вы уже программировали ранее, то это работает несколько иначе, чем в объектно-ориентированных языках программирования, таких как Java, где импорт каскадно наследует классы.
Обратите внимание, как мы использовали тег шаблона `url` для ссылки на URL шаблон `rango/<category-name>/add_page/`. `category.slug` передается в качестве параметра в тег шаблона `url` и шаблонизатор Django выдаёт нам правильный URL.

Теперь после наследования от шаблона `rango/base.html`, шаблон `category.html` уменьшился в размерах и расширяет блоки `title_block` и` body_block`. Не нужно создавать заново HTML документ, поскольку эту же сделано в `base.html`. Всё что нужно сделать - это подключить дополнительные элементы к базовому шаблону для создания законченного HTML документа, который посылается браузеру клиента. Этот созданный HTML документ будет соответствовать стандартам и содержать такие компоненты, как объявление типа документа на первой строке.

I> ### Подробнее о шаблонах 
I> Здесь мы показали как можно минимизировать повторяющуюся структуру HTML в наших шаблонах. Но язык шаблонов Django очень мощный и даже позволяет создавать свои собственные теги шаблонов.
I>
I> Шаблоны могут также использоваться для минимизации кода в представлениях Вашего приложения. Например, если Вы хотите добавить одинаковое содержимое из базы данных на каждую страницу Вашего приложения, Вы можете создать шаблон, который вызывает определенное представление для обработки повторяющейся части Ваших страниц. Это избавит Вас от необходимости вызывать Django ORM функции, которые извлекают требуемые данные для шаблона, в каждом представлении.
I>
I> Если вы ещё этого не сделали, сейчас подходящее время, чтобы прочитать официальную [документацию Django по шаблонам](https://docs.djangoproject.com/en/2.0/topics/templates/).

X> ### Упражнения
X> Теперь после того как Вы изучили эту главу, выполните приведенные ниже упражнения, чтобы закрепить то, что вы узнали о Django и шаблонах.
X>
X> - Измените все остальные существующие шаблоны внутри приложения Rango так, чтобы они наследовались от новго шаблона `base.html`. Используйте ту же последовательность действий, которая была показана выше. После выполнения этой задачи все Ваши шаблоны должны наследоваться от `base.html`.
X> - При этом убедитесь, что Вы удалили ссылки из Вашего шаблона `index.html`. Они нам больше не нужны! Также Вы можете удалить ссылку на домашнюю страницу Rango в шаблоне `about.html`.
X> - При преобразовании `index.html` оставьте изображения, которые отдаются сервером статических и медиа файлов.
X> - Обновите все URL в ссылках для приложения Rango, используя тег шаблона `url`. Вы также можете сделать это в своём модуле `views.py` - просмотрите [вспомогательную функцию `reverse()`](https://docs.djangoproject.com/en/2.0/ref/urlresolvers/#reverse).

T> ### Подксказки к упражнениям
T> - Начните с рефактиринга шаблона `about.html`.
T> - Обновите `title_block`, а затем `body_block` в каждом шаблоне.
T> - Запустите сервер для разработки и проверяйте страницу, над которой работаете. Не меняйте всю страницу сразу, потому что она может перестать работать. Постепенное внесение изменений и тестирование этих изменений - гораздо более безопасное решение.
T> - Чтобы сослаться на страницы категорий, Вы можете использовать следующий код шаблона, при этом обратите внимание на команду `{% url %}` шаблона Django.
T>
T> {lang="html",linenos=off}
T> 		<a href="{% url 'show_category' category.slug %}">{{ category.name }}</a>

<!-->
![Диаграмма классов, показывающая как Ваши шаблоны должны наследоваться от
`base.html`.](../images/rango-template-inheritance.svg)
-->

## Метод `render()` и контекст `request`
При написании представлений мы использовали несколько различных методов, но предпочтительным способом является использование вспомогательного метода `render()`. Метод `render()` требует, чтобы Вы передали `request` в качестве первого аргумента. Внутри `request` содержится информация о сессии, пользователе и т. д., смотри [официальную документацию Django по объектам запроса](https://docs.djangoproject.com/en/2.0/ref/request-response/#httprequest-objects). Передача `request` в шаблон означает, что Вы также будете иметь доступ к этой информации при создании шаблонов. В следующей главе мы будем использовать информацию о `user` - но пока проверьте все Ваши представления и убедитесь, что они реализованы с помощью метода `render()`. В противном случае ваши шаблоны не будут содержать необходимую нам позднее информацию.

I> ### Отображение и контекст
I> В качестве примера тех проверок, которые Вы должны выполнить, рассмотрим представление `about()`. Первоначально оно было реализовано с помощью жестко закодированного строкового ответа как показано ниже. Обратите внимание, что мы отправляем только строку - мы не используем запрос, переданный в качестве параметра `request`.
I>
I> {lang="python",linenos=off}
I> 	def about(request):
I> 	    return HttpResponse('Rango says: Here is the about page.
I> 	                         <a href="/rango/">Index</a>')
I>
I> Чтобы использовать шаблон, мы вызываем функцию `render()` и передаём объект `request`. Это позволит шаблонизатору получить доступ к такой информации как тип запроса (например, `GET`/`POST`) и информации, относящейся к статусу пользователя (смотри [главу 9])(#chapter-user)).
I>
I> {lang="python",linenos=off}
I> 	def about(request):
I>	    # выводит информацию о том какой метод использовался - GET или POST
I>	    print(request.method)
I>	    # выводит им пользователя, если пользователь не залогинен, выводит `AnonymousUser`
I>	    print(request.user)
I>	    return render(request, 'rango/about.html', {})
I>
I> Помните, что последний параметр `render()` - это словарь переменных контекста шаблона, который Вы можете использовать для передачи дополнительных данных в шаблонизатор Django. Поскольку у нас нет дополнительных данных для шаблона, мы передаём пустой словарь `{}`.

## Пользовательские теги шаблонов
Было бы неплохо показать различные категории, которые пользователи могут просматривать в сайдбаре на каждой странице. Учитывая то, чему мы уже научились, мы могли бы сделать следующее:

- в шаблон `base.html` мы могли бы добавить код для отображения списка категорий; и
- в каждом представлении мы можем получить доступ к объекту `Category`, извлечь все категории и вернуть его в словарь контекста.

Однако это довольно плохое решение, поскольку нам нужно будет добавить один и тот же код во все представления. [Более правильным решением, без повтороения кода](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) является создание пользовательских тегов шаблона, которые включаются в шаблон и могут запрашивать *свои* данные.

### Использование тегов шаблона
Создайте каталог `rango/templatetags` и создайте в нём два новых модуля. Один должен называться `__init__.py` и он будет пустым. Назовите второй модуль `rango_template_tags.py`. Добавьте следующий код в этот второй модуль.

{lang="python",linenos=on}
	from django import template
	from rango.models import Category
	
	register = template.Library()
	
	@register.inclusion_tag('rango/cats.html')
	def get_category_list():
	    return {'cats': Category.objects.all()}

В этом фрагменте кода посмотрите на новый метод под названием `get_category_list()`. Этот метод возвращает список категорий - но внедряя его шаблон в шаблон `rango/cats.html` (как видно из декоратора `register.inclusion_tag()`). Теерь Вы можете создать этот файл шаблона и добавить в него следующую HTML разметку:

{lang="html",linenos=on}
	<ul>
	{% if cats %}
	    {% for c in cats %}
	        <li><a href="{% url 'rango:show_category'  c.slug %}">{{ c.name }}</a></li>
	    {% endfor %}
	{% else %}
	    <li><strong>There are no categories present.</strong></li>
	{% endif %}
	</ul>

Чтобы использовать тег шаблона в Вашем шаблоне `base.html`, сначала загрузите пользовательский тег шаблона, добавив команду {% load rango_template_tags %}` в начале шаблона `base.html`. Затем вы можете создать новый блок для сайдбара - мы можем вызвать наш новый тег шаблона следующим образом.

{lang="html",linenos=off}
	<div>
	    {% block sidebar_block %}
	        {% get_category_list %}
	    {% endblock %}
	</div>

Попробуйте сделать это. Теперь все страницы, которые наследуются от `base.html`, будут также включать список категорий (который мы позднее передвинем в сторону).

T> ### Перезапустите сервер!
T> Вам нужно будет перезапускать сервер для разработки Django (или убедиться, что он перезапустился) каждый раз, когда вы изменяете пользовательские теги шаблона. Если сервер не перезагрузился, Django не зарегистрирует теги.

### Параметризированные теги шаблонов
Мы также можем добавить *параметры* к создаваемым тегам шаблонов, чтобы сделать их ещё более гибкими.  В качестве примера, мы будем использовать параметр, чтобы выделить категорию, на странице которой мы находимся. Добавить параметр просто - мы должны обновить метод `get_category_list()` следующим образом.

{lang="python",linenos=off}
	def get_category_list(cat=None):
	    return {'cats': Category.objects.all(),
	            'act_cat': cat}

Обратите внимание на добавление параметра `cat` к `get_category_list()`, что является необязательным - и если Вы не передаёте категорию, то будет использоваться значение `None`.

Теперь мы можем обновить наш шаблон `base.html`, который использует пользовательский тег шаблона, добавив в него текущую категорию, но только если она существует.

{lang="html",linenos=off}
	<div>
	    {% block sidebar_block %}
	        {% get_category_list category %}
	    {% endblock %}
	</div>

Мы также обновим шаблон `cats.html`.

{lang="html",linenos=off}
	{% for c in cats %}
	    {% if c == act_cat %}
	        <li>
	        <strong>
	              <a href="{% url 'rango:show_category' c.slug %}">{{ c.name }}</a>
	        </strong>
	        </li>
	    {% else  %}
	        <li>
	            <a href="{% url 'rango:show_category' c.slug %}">{{ c.name }}</a>
	        </li>
	    {% endif %}
	{% endfor %}

В шаблоне мы проверяем совпадает ли отображаемая категория с категорией, которая выбрана в текущем цикле `for` (т.е. `c == act_cat`). Если да, то мы выделяем название категории, делая его *полужирным* с помощью тега `<strong>`.

## Резюме
В этой главе мы показали как:

- уменьшить связь между URL-адресами и шаблонами, используя тег шаблона `url` для указания относительных URL-адресов;
- уменьшить количество шаблонного кода за счет использования наследования шаблонов; а также
- избежать повторяющегося кода, появляющегося в представлениях путем создания пользовательских тегов шаблонов.

Всё это делает Ваш код шаблонов более компактным и простым для обслуживания. Конечно шаблоны Django предоставляют гораздо больше функций - более подробную информацию можно узнать, прочитав [документацию Django по шаблонам](https://docs.djangoproject.com/en/2.0/ref/templates/).