# Аутентификация пользователя {#chapter-user}
Большинство веб-приложений просят пользователей зарегистрироваться, чтобы они могли управлять своей учетной записью и иметь доступ к специальным функциям. Для Rango мы хотим контролировать, какие действия доступны для разных пользователей. Таким образом, цель этой следующей части учебного пособия - познакомить вас с механизмами аутентификации пользователей, предоставляемыми Django. Мы будем использовать приложение `auth`, предоставляемое как часть стандартной установки Django, расположенное в пакете `django.contrib.auth`. Согласно [документации Django по аутентификации](https://docs.djangoproject.com/en/2.0/topics/auth/), приложение предоставляет следующие функциональные возможности.

- Понятие *Пользователь* (User) и модель *Пользователь* (User).
- *Права доступа* (Permissions), ряд двоичных флагов (например, да/нет), которые определяют что пользователь делать, а что нет.
- *Группы* (Groups), способ назначить права доступа сразу нескольким пользователям.
- Настраиваемая *система хеширования паролей*, неотъемлемая часть системы для обеспечения безопасности данных.
- *Формы и представления для входа пользователей в систему*, или ограничивающие доступ к содержимому сайта.

Многое Django может сделать за Вас при аутентификации пользователя. В этой главе мы рассмотрим основы, чтобы Вам было с чего начать изучение. Это поможет Вам уверенно работать с доступными инструментами и лежащими в их основе понятиями. Обратите внимание, что мы покажем вам, как настроить аутентификацию пользователя вручную с чистого листа, используя Django, но в следующей главе мы будем использовать готовое приложение, которое будет осуществлять процесс регистрации за нас.
 
## Настройка аутентификации
Перед тем как начать работать с приложением аутентификации Django, необходимо проверить настройки в файле settings.py Вашего Rango проекта.

В файле settings.py найдите кортеж INSTALLED_APPS и проверьте, что `django.contrib.auth` и `django.contrib.contenttypes` находятся внутри него, он должен выглядеть примерно, как показано ниже:

{lang="python",linenos=off}
	INSTALLED_APPS =[
	    'django.contrib.admin',
	    'django.contrib.auth',
	    'django.contrib.contenttypes',
	    'django.contrib.sessions',
	    'django.contrib.messages',
	    'django.contrib.staticfiles',
	    'rango',
	]

В то время как `django.contrib.auth` обеспечивает Django доступ к системе аутентификации, пакет `django.contrib.contenttypes` используется приложением аутентификации для отслеживания моделей, установленных в Вашей базе данных.

I> ### Осуществите миграцию, если это необходимо!
I> Если Вам нужно добавить приложения `django.contrib.auth` и `django.contrib.contenttypes` в Ваш кортеж `INSTALLED_APPS`, обновите Вашу базу данных с помощью команды `$ python manage.py migrate`. Это добавит необходимые таблицы в Вашу базу данных, например, таблицу для модели `User`.
I>
I> Обычно рекомендуется запускать команду `migrate` каждый раз, когда Вы добавляете новое приложение в проект Django - приложение может содержать модели, которые необходимо будет синхронизировать с Вашей базой данных.

## Хеширование пароля
[*Хранение паролей в открытом виде в базе данных - это то, что не следует делать ни при каких обстоятельствах.*](http://stackoverflow.com/questions/1197417/why-are-plain-text-passwords-bad-and-how-do-i-convince-my-boss-that-his-treasur) Если посторонний человек получит доступ к базе данных Вашего приложения и таблице с учетными записями пользователей, то он сможет причинить вред. К счастью, приложение `auth` по умолчанию хранит [хеш паролей пользователей](https://en.wikipedia.org/wiki/Cryptographic_hash_function), используя [алгоритм PBKDF2](http://en.wikipedia.org/wiki/PBKDF2), обеспечивая хороший уровень безопасности данных вашего пользователя. Тем не менее, если Вы хотите ещё больше контролировать то как хешируются пароли, Вы можете изменить подход, используемый Django в модуле Вашего проекта `settings.py`, добавив в кортеж переменную `PASSWORD_HASHERS`. Пример как это сделать показан ниже.

{lang="python",linenos=off}
	PASSWORD_HASHERS = (
	    'django.contrib.auth.hashers.PBKDF2PasswordHasher',
	    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
	)

Для Django важен порядок указанных хэшей и он выберет и будет использовать первый алгоритм хеширования в `PASSWORD_HASHERS` (т. е., `settings.PASSWORD_HASHERS[0]`). Если в кортеже указаны другие алгоритм хеширования, то Django будет их использовать, если первый алгоритм не заработает.

Если Вы хотите использовать более безопасный алгоритм хеширования, Вы можете установить [Bcrypt](https://pypi.python.org/pypi/bcrypt/) с помощью команды `pip install bcrypt`, а затем присвоить `PASSWORD_HASHERS` значение:

{lang="python",linenos=off}
	PASSWORD_HASHERS = [
	    'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',
	    'django.contrib.auth.hashers.BCryptPasswordHasher',
	    'django.contrib.auth.hashers.PBKDF2PasswordHasher',
	    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
	]

Как было сказано ранее, Django по умолчанию использует алгоритм PBKDF2 для хешировани паролей. Если Вы не укажете кортеж `PASSWORD_HASHERS` в `settings.py`, то Django будет использовать алгоритм хеширования паролей `PBKDF2PasswordHasher` по умолчанию. Узнать больше о хешировании паролей можно в [Django документации, посвященной тому как Django хранит пароли](https://docs.djangoproject.com/en/2.0/topics/auth/passwords/#how-django-stores-passwords).

## Валидаторы паролей
Поскольку взломщики могут попытаться ввести пароль, который достаточно легко угадать, Django предоставляет ряд методов для [валидации пароля](https://docs.djangoproject.com/en/2.0/ref/settings/#auth-password-validators). В Вашем модуле `settings.py` Django проекта, Вы увидите список вложенных словарей с названием `AUTH_PASSWORD_VALIDATORS`. Из вложенных словарей видно, что в Django 1.9 по умолчанию входит несколько встроенных средств валидации паролей для обобщенных проверок паролей, таких как длина. Для каждого валидатора может быть указан словарь `OPTIONS`, что упрощает его настройку. Например, если Вы хотите чтобы пароли имели длину не менее шести символов, Вы можете установить для параметра min_length валидатора пароля MinimumLengthValidator значение `6`. Это видно из примера показанного ниже.

{lang="python",linenos=off}
	AUTH_PASSWORD_VALIDATORS = [
	    ...
	    {
	        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
	        'OPTIONS': { 'min_length': 6, }
	    },
	    ...
	]

Также можно создавать свои собственные валидаторы паролей. Хотя в этом учебном пособии мы не рассматриваем вопрос создания пользовательских валидаторов паролей, обратитесь к [официальной документации Django посвященной валидаторам паролей](https://docs.djangoproject.com/en/2.0/topics/auth/passwords/#password-validation) для получения дополнительной информации.

## Модель `User`
Объект `User` (расположенный по адресу` django.contrib.auth.models.User`) считается ядром системы аутентификации Django. Объект `User` представляет каждого человека, взаимодействующего с приложением Django. В [Django документации по объектам User](https://docs.djangoproject.com/en/2.0/topics/auth/default/#user-objects) утверждается, что они используются, чтобы реализовать такие функции системы аутентификации как ограничение прав доступа, регистрация новых пользователей и связь содержимого сайта с его автором.

Модель `User` содержит пять основных атрибутов. Это:

-   *имя пользователя* для учетной записи пользователя;
-   *пароль* учетной записи;
-   *адрес электронной почты* пользователяthe user's *email address*;
-   *имя* пользователя; и
-   *фамилия* пользователя.

Модель `User` также имеет другие атрибуты, такие как `is_active`, `is_staff` и `is_superuser`. Эти логические поля, используются чтобы определить является ли учетная запись автивной, принадлежит ли она сотруднику или имеет привилегии суперпользователя соответственно. Прочитайте [официальную Django документацию по модели пользователя](https://docs.djangoproject.com/en/2.0/ref/contrib/auth/#django.contrib.auth.models.User), чтобы узнать полный список атрибутов, предоставляемый базовой моделью `User`.

## Дополнительные атрибуты пользователя
Если Вы хотите добавить другие атрибуты, отличающиеся от тех, которые уже предусмотрены в модели `User`, то Вы должны создать модель, которая *связана* с моделью `User`. Для нашего приложения Rango, мы хотим добавить два дополнительных атрибута для каждой учетной записи пользователя. В частности, мы хотим добавить:

- `URLField`, позволяет пользователю Rango указать свой собственный веб сайт; и
- `ImageField`, , позволяет пользователям задать изображения для своего профиля пользователя.

Для этого создадим дополнительную модель в файле `models.py` Rango. Давайте добавим новую модель под названием `UserProfile`:

{lang="python",linenos=off}
	class UserProfile(models.Model):
	    # Эта строка обязательна. Она связывает UserProfile с экземпляром модели User.
	    user = models.OneToOneField(User, on_delete=models.CASCADE)
	    
	    # Дополнительные атрибуты, которые мы хотим добавить.
	    website = models.URLField(blank=True)
	    picture = models.ImageField(upload_to='profile_images', blank=True)
	    
	    def __str__(self):
	        return self.user.username

Обратите внимание, что мы ссылаемся на модель `User`, используя связь один-к-одному. Поскольку мы ссылаемся на модель по умолчанию `User`, нам необходимо импортировать её в файл `models.py`:

{lang="python",linenos=off}
	from django.contrib.auth.models import User

Для Rango мы добавили два поля, необходимые для заполнения нашего профиля пользователя и прописали метод `__str__()`, возвращающий понятное человеку значение, когда запрашивается юникод представление экземпляра модели `UserProfile`.

Для полей `website` и `picture` мы установили значение `blank=True`. Это значит, что каждое из этих полей может быть пустым, если необходимо, т. е., пользователи могут не ввести значения для атрибутов, если не захотят.

Обратите внимание, что поле `ImageField` имеет атрибут `upload_to`. значение этого атрибута связано с переменной проекта `MEDIA_ROOT` и определяет путь, где будут храниться загруженные изображения для профиля. Например, если `MEDIA_ROOT` равен `<workspace>/tango_with_django_project/media/`, а атрибут `upload_to` - `profile_images`, то все изображения профилей будут храниться в каталоге `<workspace>/tango_with_django_project/media/profile_images/`.

Furthermore, it should be noted that the `ImageField` field has an `upload_to` attribute. The value of this attribute is conjoined with the project's `MEDIA_ROOT` setting to provide a path with which uploaded profile images will be stored. For example, a `MEDIA_ROOT` of `<workspace>/tango_with_django_project/media/` and `upload_to` attribute of `profile_images` will result in all profile images being stored in the directory `<workspace>/tango_with_django_project/media/profile_images/`. Вспомните, что в [главе о шаблонах и медиа-файлах](#chapter-templates-static) мы настраивали корневой каталог для медиа файлов.

I> ### Почему не используется наследование?
I> Кажется заманчивым добавить эти дополнительные поля путем непосредственного наследования от модели `User`. Однако, поскольку другим приложениям может также понадобиться доступ к модели, не рекомендуется использовать наследование, а вместо него применять связь один-к-одному в базе данных.

I> ### Установите PIL
I> Django поле `ImageField` использует *Python Imaging Library (PIL)*. Если Вы ещё не установили её, сделайте это с помощью команды `pip install pillow`. Если у Вас не включена поддержка `jpeg`, Вы также можете установить PIL с помощью команды `pip install pillow --global-option="build_ext" --global-option="--disable-jpeg"`.
I>
I> Вы можете узнать какие пакеты установлены в Вашем (виртуальном) окружении, введя команду `pip list`.

Чтобы сделать данные модели `UserProfile` доступными через веб-интерфейс администратора Django, импортируйте новую модель `UserProfile` в модуль Rango `admin.py`.

{lang="python",linenos=off}
	from rango.models import UserProfile

Теперь Вы можете зарегистрировать новую модель через интерфейс администратора, используя следующую строку.

{lang="python",linenos=off}
	admin.site.register(UserProfile)

I> ### Помните о миграциях!
I> Помните, что Вашу базу данных необходимо обновить при создании новой модели. Запустите:
I> `$ python manage.py makemigrations rango` 
I> из Вашего терминала или командной строки, чтобы создать скрипты для миграции новой модели `UserProfile`. Затем введите:
I> `$ python manage.py migrate` 
I> чтобы выполнить миграцию, которая создаст соответствующие таблицы в базе данных.

## Создание представления и шаблона *User Registration*
После того как спроектирована инфраструктура аутентификации, можно начать генерировать её, предоставляя пользователям нашего приложения возможность создавать новые пользовательские учетные записи. Мы добьемся этого, создав новое представление, шаблон и URL сопоставление для регистрации пользователей.

I> ### Приложение Django для регистрации пользователей
I>
I> Важно отметить, что доступно несколько стандартных пакетов для регистрации пользователей, которые упрощают множество задач, связанных с созданием своих собственных форм для регистрации и входа.
I> 
I> Тем не менее, хорошо получить некоторое представление о механике таких приложений, предже чем их использовать. Это гарантирует, что у Вас будет представление о том, что происходит внутри этих приложений. *Не попробуешь - не узнаешь*. Также это закрепит Ваши знания по работе с формами, позволит понять как расширить модель `User` и загружать медиа-файлы.

Чтобы реализовать функцию регистрации пользователя, необходимо выполнить следующие шаги:

- создать `UserForm` и `UserProfileForm`;
- добавить представление для обработки данных при создании нового пользователя;
- создать шаблон, который отображает `UserForm` и `UserProfileForm`; и
- сопоставить URL созданному представлению.

В качестве последнего шага для интеграции нашей новой функции регистрации, мы также:

- создадим ссылку на страницу регистрации на главной странице.

### Создание `UserForm` и `UserProfileForm`
Теперь в `rango/forms.py` нам нужно создать два класса, которые наследуются от `forms.ModelForm`. Мы создадим один для базового класса `User` и второй для новой только что созданной модели `UserProfile`. Два класса, наследующихся от `ModelForm`, позволят отображать HTML форму с необходимыми полями для конкретной модели, выполняя значительную часть работы за нас.

Давайте создадим наши два класса в `rango/forms.py`, которые наследуются от `forms.ModelForm`. Добавьте следующий код в модуль.

{lang="python",linenos=off}
	class UserForm(forms.ModelForm):
	    password = forms.CharField(widget=forms.PasswordInput())
	    
	    class Meta:
	        model = User
	        fields = ('username', 'email', 'password')
	    
	class UserProfileForm(forms.ModelForm):
	    class Meta:
	        model = UserProfile
	        fields = ('website', 'picture')

Заметьте, что в оба класса мы добавили [вложенный](http://www.brpreiss.com/books/opus7/html/page598.html) класс `Meta`. Как [предполагает название вложенного класса](http://www.webopedia.com/TERM/M/meta.html), все что находится внутри вложенного класса `Meta` описывает дополнительные свойства, касающиеся конкретного класса, которому он принадлежит. Каждый класс `Meta` должен иметь поле `model`. В случае класса `UserForm`, связанной с ней моделью является модель `User`. Вам также нужно указать `fields` или поля для `exclude`, чтобы определить какие поля, связанные с моделью, должны присутствовать (или нет) в отображаемой форме.

Здесь мы хотим отображать только поля `username`, `email` и `password`, связанные с моделью `User` и поля `website` и `picture`, связанные с моделью `UserProfile`. Для поля `user` в `UserProfile` необходимо создать связь с моделью `User` при регистрации пользователя. Это связано с тем, что когда мы создаём экземпляр `UserProfile`, у нас нет ещё экземпляра `User`, на который можно сослаться.

Заметьте также, что `UserForm` содержит определение атрибута `password`. Хотя экземпляр модели `User` содержит атрибут `password` по умолчанию, выводимое поле HTML формы не будет скрывать пароль. Когда пользователь будет вводить пароль, его будет видно. Обновляя атрибут мы можем указать, что экземпляр `CharField` должен скрывать введенные пользователем символы, используя виджет `PasswordInput()`.

Наконец, не забудем добавить требуемые классы в начале модуля `forms.py`! Для удобства мы привели их ниже.

{lang="python",linenos=off}
	from django import forms
	from django.contrib.auth.models import User
	from rango.models import Category, Page, UserProfile

### Создание представления `register()`
Затем необходимо вывести форму и обработать данные, введенные в неё. В файле `views.py` Rango добавьте команды импорта `import` для новых классов `UserForm` и `UserProfileForm`.

{lang="python",linenos=off}
	from rango.forms import UserForm, UserProfileForm

После этого добавьте следующее новое представление, `register()`.

{lang="python",linenos=off}
	def register(request):
	    # Логическое значение указывающее шаблону
	    # прошла ли регистрация успешно.
	    # В начале ему присвоено значение False. Код изменяет значение на
	    # True, если регистрация прошла успешно.
	    registered = False
	    
	    # Если это HTTP POST, мы заинтересованы в обработке данных формы.
	    if request.method == 'POST':
	        # Попытка извлечь необработанную информацию из формы.	
	        # Заметьте, что мы используем UserForm и UserProfileForm.
	        user_form = UserForm(data=request.POST)
	        profile_form = UserProfileForm(data=request.POST)
	        
	        # Если в две формы введены правильные данные...
	        if user_form.is_valid() and profile_form.is_valid():
	            # Сохраняем данные формы с информацией о пользователе в базу данных.
	            user = user_form.save()
	            
	            # Теперь мы хэшируем пароль с помощью метода set_password.
	            # После хэширования мы можем обновить объект "пользователь".
	            user.set_password(user.password)
	            user.save()
	            
	            # Теперь разберемся с экземпляром UserProfile.
	            # Поскольку мы должны сами назначить атрибут пользователя,
	            # необходимо приравнять commit=False. Это отложит сохранение модели,                 
	            # до тех пор пока мы не получим все необходимые данные, чтобы избежать проблем с целостностью базы данных.
	            profile = profile_form.save(commit=False)
	            profile.user = user
	            
	            # Предоставил ли пользователь изображение для профиля?
	            # Если да, необходимо извлечь его из формы и 
	            # поместить в модель UserProfile.
	            if 'picture' in request.FILES:
	                profile.picture = request.FILES['picture']
	            
	            # Теперь мы сохраним экземпляр модели UserProfile.
	            profile.save()
	            
	            # Обновляем нашу переменную, чтобы указать, 
                # что регистрация прошла успешно.
	            registered = True
	        else:
	            # Неправильная формы или формы - ошибки или ещё какая-нибудь проблема?
	            # Вывести проблемы в терминал.
	            print(user_form.errors, profile_form.errors)
	    else:
	        # Не HTTP POST запрос, следовательно, мы выводим нашу форму, используя два экземпляра ModelForm.
	        # Эти формы будут не заполненными и готовы к вводу данных от пользователя.
	        user_form = UserForm()
	        profile_form = UserProfileForm()
	    
	    # Выводим шаблон в зависимости от контекста.
	    return render(request,
	                  'rango/register.html',
	                  {'user_form': user_form,
                       'profile_form': profile_form, 
	                   'registered': registered})

Хотя представление кажется очень сложным, на самом деле оно очень похоже на реализацию представлений [добавить категорию](#section-forms-addcategory) и [добавить страницу](#section-forms-addpage). Тем не менее здесь нам нужно было обрабатывать два различных экземпляра `ModelForm` - один для модели `User` и второй для модели `UserProfile`. Нам также необходимо обработать изображение для профиля пользователя, если он или она захочет его загрузить.

Более того нам нужно установить связь между двумя созданными экземплярами модели. После создания нового экземпляра модели `User` мы сослались на него в экземпляре `UserProfile` в строке `profile.user = user`. В этом месте заполняем атрибут `user` формы `UserProfileForm`, который мы скрыли от пользователей.

### Создание шаблона *Регистрация* (Registration)
Теперь нам нужно создать шаблон, который будет использоваться нашим новым представлением `register()`. Создайте новый файл шаблона, `rango/register.html`, и добавьте следующий код.

{lang="html",linenos=on}
	{% extends 'rango/base.html' %}
	{% load staticfiles %}
	
	{% block title_block %}
	    Register
	{% endblock %}
	
	{% block body_block %}
	    <h1>Register for Rango</h1>
	    {% if registered %}
	        Rango says: <strong>thank you for registering!</strong>
	        <a href="{% url 'rango:index' %}">Return to the homepage.</a><br />
	    {% else %}
	        Rango says: <strong>register here!</strong><br />
	        <form id="user_form" method="post" action="{% url 'rango:register' %}"
	              enctype="multipart/form-data">
	        
	        {% csrf_token %}
	        
	        <!-- Выводим на экран каждую форму.  -->
	        {{ user_form.as_p }}
	        {{ profile_form.as_p }}
	        
	        <!-- Создаем кнопку для отправки данных формы. -->
	        <input type="submit" name="submit" value="Register" />
	    </form>
	    {% endif %}
	{% endblock %}

I> ### Использование тега шаблона `url`
I> Обратите внимание, что мы используем тег шаблона `url` в приведенном выше коде шаблона, т. е., `{% url 'register' %}`.
I> Это означает, что когда мы будем сопоставлять представлению URL, необходимо назвать его `register`.

Первое на что нужно обратить внимание здесь - это то, что шаблон использует переменную `registered`, которая применялась в нашем представлении для обозначения того прошла ли регистрация успешно или нет. Учтите, что переменная `registered` должна быть равна `False`, чтобы шаблон вывел форму для регистрации - в противном случае выводится сообщение об успешной регистрации.

Затем мы использовали шаблонную функцию `as_p` в `user_form` и `profile_form`. Она оборачивает каждый элемент в форме в абзац (обозначаемый в HTML тегом `<p>`). Это гарантирует, что каждый элемент появится на новой строке.

Наконец в элемент `<form>` мы добавили атрибут `enctype`. Если пользователь пытается загрузить изображение, ответ от формы может содержать двоичные данные и может быть довольно большой. Поэтому ответ должен быть разбит на несколько частей при передаче обратно на сервер. Таким образом, это нужно обозначить с помощью `enctype="multipart/form-data"`. Это сообщает HTTP-клиенту (веб-браузеру) о необходимости упаковать и отправить данные. В противном случае сервер не получит все данные, отправленные пользователем.

W> ### Составные сообщения и бинарные файлы
W> Вы должны быть знакомы с атрибутом `enctype` элемента `<form>`. Если Вы хотите позволить пользователям загружать файлы из формы, *обязательным* условием является присвоение `enctype` значения `multipart/form-data`. Эта комбинация атрибут и значения указывают Вашему браузеру посылать данные формы особым образом обратно на сервер. В частности, данные, представляющие Ваш файл деляется на части и отправляются. Дополнительную информацию можно узнать в [этом замечательном ответе на Stack Overflow](http://stackoverflow.com/a/4526286).

Кроме того не забудьте добавить CSRF токен, т. е. `{% csrf_token %}` в Ваш элемент `<form>`! Если Вы не сделаете этого, слой промежуточного программного обеспечения Django для защиты от [межсайтовой подделки запроса](https://en.wikipedia.org/wiki/Cross-site_request_forgery) откажется принимать содержимое формы, возвращая ошибку. 

### Сопоставление URL представлению `register()`
После того как наше новое представление и связанный с ним шаблон созданы, мы можем добавить для него URL сопоставление. В URL модуле Rango `rango/urls.py` измените кортеж `urlpatterns` как показано ниже.
 
{lang="python",linenos=off}
	urlpatterns = [
	    path('', views.index, name='index'),
	    path('about/', views.about, name='about'),
	    path('category/<slug:category_name_slug>/add_page/', views.add_page, name='add_page'),
	    path('category/<slug:category_name_slug>/', views.show_category, name='show_category'),
	    path('add_category/', views.add_category, name='add_category'),
		path('register/', views.register, name='register'), # Добавляем новый шаблон!

	]

Только что добавленный шаблон (самый последний в списке) связывает URL `/rango/register/` с представлением `register()`. Также обратите внимание на добавление `name` для нашего нового URL, `register`, которое мы использовали в шаблоне, когда записывали тег шаблона `url`, т. е., `{% url 'register' %}`.

### Добавляем ссылку
Наконец, добавим ссылку, указывающую на наш новый URL для регистрации модифицируя шаблон `base.html`. Обновите `base.html` так, чтобы неупорядоченный список ссылок, который отображается на каждой странице содержал ссылку, позволяющую пользователям зарегистрироваться.

{lang="html",linenos=off}
	<ul>
		<li><a href="{% url 'rango:add_category' %}">Add a New Category</a></li>
		<li><a href="{% url 'rango:about' %}">About</a></li>	
		<li><a href="{% url 'rango:index' %}">Index</a></li>
		<li><a href="{% url 'rango:register' %}">Sign Up</a></li>
	</ul>

### Пример работы
Теперь когда всё сделано, попробуйте протестировать работу. Запустите свой сервер для разработки Django и попытайтесь зарегистрироваться как новый пользователь. зарузите изображение для профиля если хотите. Ваша форма для регистрации должна выглядеть так, как показано на [рисунке ниже](#fig-rango-register-form).

{id="fig-ch9-user-register"}
![Снимок экрана с базовой формой для регистрации, которую Вы создадите при изучении этого учебного пособия.](images/ch9-rango-register-form.png)

После появления сообщения о том, что Вы были успешно зарегистрированы, в базе данных должна появиться новая запись в моделях `User` и `UserProfile`. Убедитесь, что это так, зайдя в интерфейс администратора Django.

## Добавление функции входа в систему
После того как реализована возможность регистрации, теперь нам необходимо добавить для пользователей Rango функцию входа в систему. Для этого нужно выполнить следующую последовательность действий:

-	Создать представление login для обработки учетных данных пользователей 
-	Создать шаблон login для отображения формы входа в систему
-	Сопоставить представлению login URL
-	Создать ссылку на форму входа в систему с главной страницы

### Создание представления login()
Сначала откройте модуль с представлениями Rango `rango/views.py` и создайте новое представление с названием `user_login()`. Это представление осуществляет обработку данных из нашей формы для входа и пытается залогинить пользователя с указанными данными.

{lang="python",linenos=off}
	def user_login(request):
	    # Если запрос HTTP POST, пытаемся извлечь нужную информацию.
	    if request.method == 'POST':
	        # Получаем имя пользователя и пароль, вводимые пользователем.
	        # та информация извлекается из формы входа в систему.
	        # Мы используем request.POST.get('<имя переменной>') 
	        # вместо request.POST['<имя переменной>'], потому что
	        # request.POST.get('<variable>') вернет None, если 
	        # значения не существует, тогда как request.POST['<variable>']
	        # создаст исключение KeyError.
	        username = request.POST.get('username')
	        password = request.POST.get('password')
	        
	        # Используйте Django, чтобы проверить является ли правильным
	        # сочетание имя пользователя/пароль - если да, то возвращается объект User.
	        user = authenticate(username=username, password=password)
	        
	        # Если мы получили объект User, то данные верны.
	        # Если получено None (так Python представляет отсутствие значения), то пользователь
	        # с такими учетными данными не был найден.
	        if user:
	            # Аккаунт активен? Он может быть отключен.
	            if user.is_active:
	                # Если учетные данные верны и аккаунт активен, мы можем позволить пользователю войти в систему.
	                # Мы возвращаем его обратно на главную страницу.
	                login(request, user)
	                return HttpResponseRedirect(reverse('index'))
	            else:
	                # Использовался не активный аккуант - запретить вход!
	                return HttpResponse("Your Rango account is disabled.")
	        else:
	            # Были введены неверные данные для входа. Из-за этого вход в систему не возможен.
	            print("Invalid login details: {0}, {1}".format(username, password))
	            return HttpResponse("Invalid login details supplied.")
	        
	    # Запрос не HTTP POST, поэтому выводим форму для входа в систему.
	    # В этом случае скорее всего использовался HTTP GET запрос.
	    else:
	        # Ни одна переменная контекста не передается в систему шаблонов, следовательно, используется
	        # объект пустого словаря...
	        return render(request, 'rango/login.html', {})

Это представление может показаться сложным, так как оно должно учитывать различные ситуации. Как и в предыдущих примерах, представление `user_login()` осуществляет отображение формы и её обработку - где форма в этот раз содержит поля `username` и `password`.

Во-первых, если обращение к представлению осуществлялось через HTTP GET метод, то отображается форма входа в систему. Однако, если форма была передана через HTTP POST метод, то мы должны обработать форму.

Если через POST запрос передана форма без ошибок, то из формы извлекаются имя пользователя и пароль. Эти данные затем используются, чтобы попытаться аутентифицировать пользователя. Django функция `authenticate()` проверяет соответствует ли введенная комбинация имя пользователя/пароль учетной записи. Если существует пользователь с указанный паролем, то возвращается объект `User` и `None` - в противном случае.

Если мы получили объект `User`, то можем проверить, является ли учетная запись активной или нет - если активна, то мы можем вызвать Django функцию `login()`, которая указывает Django, что пользователь вошел в систему.

Однако если передана форма с ошибкой - например, пользователь не ввел имя или пароль - то опять выводится форма входу в систему с сообщениями об ошибках (например, было введена неверная комбинация имя пользователя/пароль).

Также обратите внимание, что мы использовали новый класс `HttpResponseRedirect`. Как видно из названия, ответ, генерируемый экземпляром класса `HttpResponseRedirect` указывает веб-браузеру клиента перейти по URL-адресу, указанному в качестве аргумента. Обратите внимание, что при этом вернется HTTP код состояния `302`, который обозначает редирект вместо кода состояния `200` (OK). Смотри [документацию Django по редиректам](https://docs.djangoproject.com/en/2.0/ref/request-response/#django.http.HttpResponseRedirect) для получения дополнительной информации.

Наконец, мы используем другой метод Django `reverse` для получения URL-адреса приложения Rango. Он выполняет поиск URL шаблонов в модуле `urls.py` Rango с названием `'index'` и подставляет соответствующий шаблон. Таким образом, если мы в дальнейшем изменим URL сопоставление, это не приведет к нарушению работы нашего нового представления.

Все эти функции и классы предоставляются Django. Таким образом, Вам нужно импортировать их. Добавьте следующие команды `import` в начале `rango/views.py`.

{lang="python",linenos=off}
	from django.contrib.auth import authenticate, login
	from django.http import HttpResponseRedirect, HttpResponse
	from django.urls import reverse

### Создание шаблона *Login*
После создания нашего нового представления, нам надо создать новый шаблон, `login.html`, который позволит пользователям ввести их учетные данные. Хотя мы знаем, что шаблон будет находиться в каталоге `templates/rango/`, задачу как правильно назвать файл Вы должны решить сами. Просмотрите на вышеприведенный пример кода, чтобы найти название в коде нового представления `user_login()`. В Ваш новый файл шаблона, добавьте следующий код:

{lang="html",linenos=off}
	{% extends 'rango/base.html' %}
	{% load staticfiles %}
	
	{% block title_block %}
	    Login
	{% endblock %}
	
	{% block body_block %}
	<h1>Login to Rango</h1>
	<form id="login_form" method="post" action="{% url 'login' %}">
	    {% csrf_token %}
	    Username: <input type="text" name="username" value="" size="50" />
	    <br />
	    Password: <input type="password" name="password" value="" size="50" />
	    <br />
	    <input type="submit" value="submit" />
	</form>
	{% endblock %}

Убедитесь, что атрибуты `name` тегов *input* совпадают с названиями переменных, которые Вы определили в представлении `user_login()`. Например, `username` для имени пользователя и `password` для пароля. Не забудьте также о `{% csrf_token %}`!

### Сопоставление URL представлению Login
Создав Ваш шаблон *Login*, теперь мы можем сопоставить URL представлению `user_login()`. Измените модуль Rango `urls.py` так, чтобы его список `urlpatterns` содержал следующее сопоставление.

{lang="python",linenos=off}
	path('login/', views.user_login, name='login'),

### Создание ссылки
Наконец, для удобства пользователей Rango мы создадим ссылку для перехода на страницу входа в систему. Для этого мы отредактируем шаблон `base.html` внутри каталога `templates/rango/`. Добавьте следующую ссылку в Ваш список.

{lang="html",linenos=off}
	<ul>
	    ...
	    <li><a href="{% url 'rango:login' %}">Login</a></li>
	</ul>

Также вы можете изменить заголовок главной страницы, в котором будете выдавать сообщение, обращенное к пользователю, если он вошел в систему и стандартное сообщение, которое видно всем, если нет. В шаблоне `index.html` найдите сообщение, которое показано в приведенном ниже фрагменте кода.

{lang="html",linenos=off}
	hey there partner!

Замените эту строку следующим кодом.

{lang="html",linenos=off}
	{% if user.is_authenticated %}
	    howdy {{ user.username }}!
	{% else %}
	    hey there partner!
	{% endif %}

Как видно из кода, мы использовали язык шаблонов Django для проверки аутентифицирован ли пользователь с помощью тега `{% if user.is_authenticated %}`. Если пользователь вошел в систему, то Django предоставляет нам доступ к объекту `user`. Мы можем узнать с помощью этого объекта: вошел ли пользователь в систему (аутентифицирован ли он). Если да, мы можем также получить информацию о нем или ней. В вышеприведенном примере, если пользователь вошел в систему, то отображается его имя, а в противном случае отображается стандартное сообщение `hey there partner!`.

### Пример работы
Запустите сервер для разработки Django и попытайтесь войти в приложение. На [рисунке ниже](#fig-ch9-user-login) показаны снимки экрана для страницы входа в систему и главной страницы.

{id="fig-ch9-user-login"}
![Снимки экрана, показывающие заголовок, который пользователи видят, когда вход в систему не осуществлен и когда вход осуществлен с именем пользователя `somebody`.](images/ch9-rango-login-message.png)

После выполнения вышеперечисленных действий, вход в систему пользователей теперь должен работать. Чтобы всё проверить, запустите сервер для разработки Django и попытайтесь зарегистрировать новую учетную запись. После успешной регистрации, у Вас должно получиться войти в систему, используя данные, которые Вы только что предоставили.

## Ограничение доступа
Теперь, когда пользователи могут входить в приложение Rango мы можем ограничить доступ к определенным частям приложения в соответствии с ТЗ, т. е., чтобы только зарегистрированные пользователи могли добавлять категории и страницы. Используя Django этого можно добиться несколькими способами:

- В шаблоне, мы можем использовать тег шаблона `{% if user.authenticated %}`, чтобы изменить внешний вид страницы (было показано выше).
- В представлении, путем непосредственной обработки объекта `request`  и проверки аутентифицирован ли пользователь.
- Или, используя функцию *декоратор* `@login_required`, предоставляемый Django, которая проверяет аутентифицирован ли пользователь.

Второй способ проверяет вошел ли пользователь в систему, используя метод `user.is_authenticated()`. Объект `user` доступен через объект `request`, который передается представлению. Следующий пример демонстрирует этот способ.

{lang="python",linenos=off}
	def some_view(request):
	    if not request.user.is_authenticated():
	        return HttpResponse("You are logged in.")
	    else:
	        return HttpResponse("You are not logged in.")

Третий способ использует [Python декораторы](http://wiki.python.org/moin/PythonDecorators). Декораторы получили такое название благодаря [шаблону проектирования программного обеспечения с таким же названием](http://en.wikipedia.org/wiki/Decorator_pattern). Они могут динамически изменять функциональное назначение функции, метода или класса без необходимости непосредственного редактирования этой функции, метода или класса.

В Django существует декоратор `login_required()`, который мы можем присоединить к любому представлению, для работы которого нужно чтобы пользователь вошел в систему. Если пользователь не вошел в систему и попытается получить доступ к представлению с декоратором `login_required()`, то он будет переадресован на другую страницу [по Вашему выбору](https://docs.djangoproject.com/en/2.0/ref/settings/#login-url)) - как правило, на страницу входа в систему.

### Ограничение доступа с помощью декоратора

Применим только что полученные значения на практике, создав представление в модуле Rango `views.py` с названием `restricted()` и добавив следующий код

{lang="python",linenos=off}
	@login_required
	def restricted(request):
	    return HttpResponse("Since you're logged in, you can see this text!")

Обратите внимание, чтобы использовать декоратор, его надо поместить *непосредственно над* названием функции и поставить `@` перед названием декоратора. Python выполнит декоратор до кода Вашей функции/метода. Поскольку декоторов - это просто функция, Вы всё равно должны импортировать её, если она нахожится во внешнем модуле. Так как `login_required()` находится в другом файле, следующая команда импорта необходима в начале `views.py`.

{lang="python",linenos=off}
	from django.contrib.auth.decorators import login_required

Мы также добавим ещё один шаблон в список `urlpatterns` Rango в файле `urls.py`. Добавьте следующую строку кода.

{lang="python",linenos=off}
	path('restricted/', views.restricted, name='restricted'),
	
И затем добавьте в `base.html` ссылку на страницу с ограниченным доступом.

{lang="html",linenos=off}
	<ul>
	    ...
		<li><a href="{% url 'rango:restricted' %}">Restricted</a></li>	
	</ul>

Также необходимо учесть случай, когда пользователь пытается получить доступ к представлению `restricted()`, но не вошел в систему. Что нужно делать в этом случае? Самый простой вариант - переадресовать его или её на страницу доступную всем пользователям, например, страницу регистрации. Django позволяет указать страницу для переадресации в файле `settings.py`, расположенном в каталоге конфигурации проекта. В `settings.py` определите переменную `LOGIN_URL` с URL, на который нужно перенаправить пользователей, не вошедших в систему, т. е., на страницу входа в систему, расположенную по адресу `/rango/login/`:

{lang="python",linenos=off}
	LOGIN_URL = '/rango/login/'

Это гарантирует, что декоратор `login_required()` переадресует любого пользователя, который не вошел в систему, на URL `/rango/login/`.

## Выход из системы
Чтобы пользователи могли корректно выйти из системы, хорошо было бы предоставить им возможность выхода из системы. В Django существует удобная функция `logout()`, которая гарантирует правильный и безопасный выход пользовательтелей из системы. Функция `logout()` гарантирует завершение сессии. После этого последующие попытки доступа к представлению, которое требует аутентификации, приведут к отказу в доступе, пока они снова не войдут в систему.
Для реализации функции выхода из системы в `rango/views.py` добавьте представление `user_logout()` со следующим кодом.

{lang="python",linenos=off}
	# Используйте декоратор login_required(), чтобы гарантировать, что только авторизированные пользователи
	# смогут получить доступ к представлению.
	@login_required
	def user_logout(request):
	    # Поскольку мы знаем, что только вошедшие в систему пользователи имеют доступ к этому представлению, можно осуществить выход из системы
	    logout(request)
	    # Перенаправляем пользователя обратно на главную страницу.
	    return HttpResponseRedirect(reverse('index'))

Вам также нужно импортировать функцию `logout` в начале `views.py`.

{lang="python",linenos=off}
	from django.contrib.auth import logout

После создания представления, сопоставьте URL `/rango/logout/` представлению `user_logout()`, изменив список `urlpatterns` в `urls.py` Rango.

{lang="python",linenos=off}
	path('logout/', views.user_logout, name='logout'),

Теперь после реализации функции выхода пользователя из системы, осталось добавить несколько последних штрихов. Было бы удобно, если бы существовала ссылка на главной странице, позволяющая пользователям простым нажатием на неё выйти из системы. Однако подумайте: необходимо ли выдавать такую ссылку пользователю, который не вошел в систему? Скорее всего нет - такому пользователю, например, можно выдать, например, ссылку на страницу регистрации.

Как в предыдущем разделе, изменим шаблон Rango `base.html` и используем объект `user` из контекта шаблона, чтобы определить какую ссылку показывать. Найдите список со ссылками внизу страницы и замените его следующим кодом. Учтите, что мы также добавили ссылку на нашу страницу с ограниченным доступом `/rango/restricted/`.

{lang="html",linenos=off}
	<ul>
	{% if user.is_authenticated %}
	    <li><a href="{% url 'rango:restricted' %}">Restricted Page</a></li>
	    <li><a href="{% url 'rango:logout' %}">Logout</a></li>	
	{% else %}
	    <li><a href="{% url 'rango:login' %}">Sign In</a></li>
	    <li><a href="{% url 'rango:register' %}">Sign Up</a></li>			
	{% endif %}
	    <li><a href="{% url 'rango:add_category' %}">Add a New Category</a></li>
	    <li><a href="{% url 'rango:about' %}">About</a></li>	
	    <li><a href="{% url 'rango:index' %}">Index</a></li>
	</ul>

Из этого фрагмента кода видно, что когда пользователь прошел аутентификацию и вошел в систему, он или она видит ссылки `Restricted Page` и `Logout`. Если он или она не вошел в систему, отображаются ссылки `Register Here` и `Login`. Ссылки `About` и `Add a New Category` находятся за условными блоками, поэтому доступны как анонимным, так и авторизированным пользователям.

## Допонительные возможности
В этой главе мы рассмотрели несколько важных принципов работы с системой аутентификации пользователей в Django. Мы показали основы установки приложения Django `django.contrib.auth` в наш проект. Кроме того, мы также показали как реализовать модель профиля пользователя, которая позволяет добавить дополнительные поля к базовой модели `django.contrib.auth.models.User`. Мы также подробно описали, как настроить приложение, чтобы позволить пользователям регистрироваться, входить в систему, выходить из системы и контролировать доступ. Для получения дополнительной информации об аутентификации и регистрации пользователей обратитесь к [документации Django по аутентификации](https://docs.djangoproject.com/en/2.0/topics/auth/).

Однако во многих веб-приложениях концепция аутентификации пользователей расширяется. Например, Вы можете захотеть регистрировать только пользователей, указавших реально существующий адрес электронной почты. Хотя мы могли бы реализовать эту функцию, зачём изобретать велосипед, если она уже реализована? Приложение `django-registration-redux` было разработано, чтобы значительно упростить процесс добавления дополнительных функций, связанных с аутентификацией пользователей. Мы рассмотрим как можно использовать этот пакет в [следующей главе](#chapter-redux).

X> ### Упражнения
X> Пока что выполните следующие два упражнения, чтобы закрепить то, чему Вы научились в этой главе.
X>
X> - Настройте приложение так, чтобы только зарегистрированные пользователи могли добавлять категории и страницы, а не зарегистрированные могли только просматривать или использовать категории и страницы. Также убедитесь, что ссылка, позволяющая добавлять страницы появляется только если пользователь, просматривает веб сайт, войдя в систему.
X> - Выдавайте информативные сообщения об ошибках, когда пользователи неправильно вводят свои имена или пароли.
X> - Применяя свои знания о шаблонах, преобразуйте представление с ограниченным доступом так, чтобы оно использовало шаблон. Назовите шаблон `restricted.html` и убедитесь, что он тоже наследуется от шаблона Rango `base.html`.